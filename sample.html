<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Funcgraph Visualization</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background-color: #f5f5f5;
            padding: 20px;
            line-height: 1.5;
            margin: 0;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow-x: auto;
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }
        .line-container {
            display: flex;
            align-items: flex-start;
            padding: 2px 5px;
            border-radius: 3px;
            transition: background-color 0.2s;
            white-space: pre;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        .line-container:hover {
            background-color: #f0f0f0;
        }
        .line-number {
            display: inline-block;
            width: 40px;
            text-align: right;
            padding-right: 10px;
            color: #999;
            user-select: none;
            flex-shrink: 0;
        }
        .line-content {
            flex-grow: 1;
        }
        .expand-btn {
            display: inline-block;
            width: 16px;
            height: 16px;
            background-color: #4CAF50;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 16px;
            font-size: 12px;
            margin-left: 5px;
            cursor: pointer;
            opacity: 0.5;
            transition: opacity 0.2s;
            user-select: none;
            vertical-align: middle;
            flex-shrink: 0;
        }
        .expand-btn:hover {
            opacity: 1;
        }
        .expanded-content {
            display: none;
            margin-left: 50px;
            padding: 10px;
            background-color: #f9f9f9;
            border-left: 2px solid #4CAF50;
            border-radius: 0 4px 4px 0;
            white-space: pre;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }
        .location-link {
            display: block;
            padding: 3px 5px;
            color: #0366d6;
            text-decoration: none;
            margin: 2px 0;
            border-radius: 3px;
            white-space: pre;
        }
        .location-link:hover {
            background-color: #eaeaea;
            text-decoration: underline;
        }
        .source-line {
            display: block;
            padding: 2px 0;
            white-space: pre;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        .current-line {
            background-color: #fff3cd;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Funcgraph Visualization v0.1 @dolinux</h1>
        <div id="content">
<div class="line-container" id="line_0_container"><span class="line-number">1</span><span class="line-content">#&nbsp;tracer:&nbsp;function_graph</span></div><div class="line-container" id="line_1_container"><span class="line-number">2</span><span class="line-content">#</span></div><div class="line-container" id="line_2_container"><span class="line-number">3</span><span class="line-content">#&nbsp;CPU&nbsp;&nbsp;DURATION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FUNCTION&nbsp;CALLS</span></div><div class="line-container" id="line_3_container"><span class="line-number">4</span><span class="line-content">#&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;|</span></div><div class="line-container" id="line_4_container"><span class="line-number">5</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;mutex_unlock()&nbsp;{&nbsp;/*&nbsp;&lt;-rb_simple_write+0xf4/0x170&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_4')">+</span></div><div class="expanded-content" id="line_4_content"><div class="location-link"><strong>rb_simple_write+0xf3/0x170:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/mutex.h#L253" target="_blank">class_mutex_destructor&nbsp;at&nbsp;./include/linux/mutex.h:253</a><div class="source-line"> 248</div><div class="source-line"> 249 	extern void mutex_unlock(struct mutex *lock);</div><div class="source-line"> 250</div><div class="source-line"> 251 	extern int atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock);</div><div class="source-line"> 252</div><div class="source-line current-line">&gt;253&lt;	DEFINE_GUARD(mutex, struct mutex *, mutex_lock(_T), mutex_unlock(_T))</div><div class="source-line"> 254 	DEFINE_GUARD_COND(mutex, _try, mutex_trylock(_T))</div><div class="source-line"> 255 	DEFINE_GUARD_COND(mutex, _intr, mutex_lock_interruptible(_T), _RET == 0)</div><div class="source-line"> 256</div><div class="source-line"> 257 	extern unsigned long mutex_get_owner(struct mutex *lock);</div><div class="source-line"> 258</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/trace/trace.c#L9831" target="_blank">(inlined&nbsp;by)&nbsp;rb_simple_write&nbsp;at&nbsp;kernel/trace/trace.c:9831</a><div class="source-line"> 9826 		ret = kstrtoul_from_user(ubuf, cnt, 10, &amp;val);</div><div class="source-line"> 9827 		if (ret)</div><div class="source-line"> 9828 			return ret;</div><div class="source-line"> 9829</div><div class="source-line"> 9830 		if (buffer) {</div><div class="source-line current-line">&gt;9831&lt;			guard(mutex)(&amp;trace_types_lock);</div><div class="source-line"> 9832 			if (!!val == tracer_tracing_is_on(tr)) {</div><div class="source-line"> 9833 				val = 0; /* do nothing */</div><div class="source-line"> 9834 			} else if (val) {</div><div class="source-line"> 9835 				tracer_tracing_on(tr);</div><div class="source-line"> 9836 				if (tr-&gt;current_trace-&gt;start)</div><div style="height: 10px;"></div></div><div class="line-container" id="line_5_container"><span class="line-number">6</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.208&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;__mutex_unlock_slowpath();&nbsp;/*&nbsp;&lt;-rb_simple_write+0xf4/0x170&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_5')">+</span></div><div class="expanded-content" id="line_5_content"><div class="location-link"><strong>rb_simple_write+0xf3/0x170:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/mutex.h#L253" target="_blank">class_mutex_destructor&nbsp;at&nbsp;./include/linux/mutex.h:253</a><div class="source-line"> 248</div><div class="source-line"> 249 	extern void mutex_unlock(struct mutex *lock);</div><div class="source-line"> 250</div><div class="source-line"> 251 	extern int atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock);</div><div class="source-line"> 252</div><div class="source-line current-line">&gt;253&lt;	DEFINE_GUARD(mutex, struct mutex *, mutex_lock(_T), mutex_unlock(_T))</div><div class="source-line"> 254 	DEFINE_GUARD_COND(mutex, _try, mutex_trylock(_T))</div><div class="source-line"> 255 	DEFINE_GUARD_COND(mutex, _intr, mutex_lock_interruptible(_T), _RET == 0)</div><div class="source-line"> 256</div><div class="source-line"> 257 	extern unsigned long mutex_get_owner(struct mutex *lock);</div><div class="source-line"> 258</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/trace/trace.c#L9831" target="_blank">(inlined&nbsp;by)&nbsp;rb_simple_write&nbsp;at&nbsp;kernel/trace/trace.c:9831</a><div class="source-line"> 9826 		ret = kstrtoul_from_user(ubuf, cnt, 10, &amp;val);</div><div class="source-line"> 9827 		if (ret)</div><div class="source-line"> 9828 			return ret;</div><div class="source-line"> 9829</div><div class="source-line"> 9830 		if (buffer) {</div><div class="source-line current-line">&gt;9831&lt;			guard(mutex)(&amp;trace_types_lock);</div><div class="source-line"> 9832 			if (!!val == tracer_tracing_is_on(tr)) {</div><div class="source-line"> 9833 				val = 0; /* do nothing */</div><div class="source-line"> 9834 			} else if (val) {</div><div class="source-line"> 9835 				tracer_tracing_on(tr);</div><div class="source-line"> 9836 				if (tr-&gt;current_trace-&gt;start)</div><div style="height: 10px;"></div></div><div class="line-container" id="line_6_container"><span class="line-number">7</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.904&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;}&nbsp;/*&nbsp;mutex_unlock&nbsp;*/</span></div><div class="line-container" id="line_7_container"><span class="line-number">8</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.107&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;preempt_count_add();&nbsp;/*&nbsp;&lt;-vfs_write+0x143/0x530&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_7')">+</span></div><div class="expanded-content" id="line_7_content"><div class="location-link"><strong>vfs_write+0x142/0x530:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/percpu-rwsem.h#L114" target="_blank">percpu_up_read&nbsp;at&nbsp;./include/linux/percpu-rwsem.h:114</a><div class="source-line"> 109</div><div class="source-line"> 110 	static inline void percpu_up_read(struct percpu_rw_semaphore *sem)</div><div class="source-line"> 111 	{</div><div class="source-line"> 112 		rwsem_release(&amp;sem-&gt;dep_map, _RET_IP_);</div><div class="source-line"> 113</div><div class="source-line current-line">&gt;114&lt;		preempt_disable();</div><div class="source-line"> 115 		/*</div><div class="source-line"> 116 		 * Same as in percpu_down_read().</div><div class="source-line"> 117 		 */</div><div class="source-line"> 118 		if (likely(rcu_sync_is_idle(&amp;sem-&gt;rss))) {</div><div class="source-line"> 119 			this_cpu_dec(*sem-&gt;read_count);</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/fs/super.h#L14" target="_blank">(inlined&nbsp;by)&nbsp;__sb_end_write&nbsp;at&nbsp;./include/linux/fs/super.h:14</a><div class="source-line"> 9 	 * These are internal functions, please use sb_start_{write,pagefault,intwrite}</div><div class="source-line"> 10 	 * instead.</div><div class="source-line"> 11 	 */</div><div class="source-line"> 12 	static inline void __sb_end_write(struct super_block *sb, int level)</div><div class="source-line"> 13 	{</div><div class="source-line current-line">&gt;14&lt;		percpu_up_read(sb-&gt;s_writers.rw_sem + level - 1);</div><div class="source-line"> 15 	}</div><div class="source-line"> 16</div><div class="source-line"> 17 	static inline void __sb_start_write(struct super_block *sb, int level)</div><div class="source-line"> 18 	{</div><div class="source-line"> 19 		percpu_down_read_freezable(sb-&gt;s_writers.rw_sem + level - 1, true);</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/fs/super.h#L77" target="_blank">(inlined&nbsp;by)&nbsp;sb_end_write&nbsp;at&nbsp;./include/linux/fs/super.h:77</a><div class="source-line"> 72 	 * Decrement number of writers to the filesystem. Wake up possible waiters</div><div class="source-line"> 73 	 * wanting to freeze the filesystem.</div><div class="source-line"> 74 	 */</div><div class="source-line"> 75 	static inline void sb_end_write(struct super_block *sb)</div><div class="source-line"> 76 	{</div><div class="source-line current-line">&gt;77&lt;		__sb_end_write(sb, SB_FREEZE_WRITE);</div><div class="source-line"> 78 	}</div><div class="source-line"> 79</div><div class="source-line"> 80 	/**</div><div class="source-line"> 81 	 * sb_end_pagefault - drop write access to a superblock from a page fault</div><div class="source-line"> 82 	 * @sb: the super we wrote to</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/fs.h#L2701" target="_blank">(inlined&nbsp;by)&nbsp;file_end_write&nbsp;at&nbsp;./include/linux/fs.h:2701</a><div class="source-line"> 2696 	 */</div><div class="source-line"> 2697 	static inline void file_end_write(struct file *file)</div><div class="source-line"> 2698 	{</div><div class="source-line"> 2699 		if (!S_ISREG(file_inode(file)-&gt;i_mode))</div><div class="source-line"> 2700 			return;</div><div class="source-line current-line">&gt;2701&lt;		sb_end_write(file_inode(file)-&gt;i_sb);</div><div class="source-line"> 2702 	}</div><div class="source-line"> 2703</div><div class="source-line"> 2704 	/**</div><div class="source-line"> 2705 	 * kiocb_start_write - get write access to a superblock for async file io</div><div class="source-line"> 2706 	 * @iocb: the io context we want to submit the write with</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/read_write.c#L694" target="_blank">(inlined&nbsp;by)&nbsp;vfs_write&nbsp;at&nbsp;fs/read_write.c:694</a><div class="source-line"> 689 		if (ret &gt; 0) {</div><div class="source-line"> 690 			fsnotify_modify(file);</div><div class="source-line"> 691 			add_wchar(current, ret);</div><div class="source-line"> 692 		}</div><div class="source-line"> 693 		inc_syscw(current);</div><div class="source-line current-line">&gt;694&lt;		file_end_write(file);</div><div class="source-line"> 695 		return ret;</div><div class="source-line"> 696 	}</div><div class="source-line"> 697</div><div class="source-line"> 698 	/* file_ppos returns &amp;file-&gt;f_pos or NULL if file is stream */</div><div class="source-line"> 699 	static inline loff_t *file_ppos(struct file *file)</div><div style="height: 10px;"></div></div><div class="line-container" id="line_8_container"><span class="line-number">9</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.086&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;preempt_count_sub();&nbsp;/*&nbsp;&lt;-vfs_write+0x172/0x530&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_8')">+</span></div><div class="expanded-content" id="line_8_content"><div class="location-link"><strong>vfs_write+0x171/0x530:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/percpu-rwsem.h#L134" target="_blank">percpu_up_read&nbsp;at&nbsp;./include/linux/percpu-rwsem.h:134</a><div class="source-line"> 129 			 * will also see our critical section.</div><div class="source-line"> 130 			 */</div><div class="source-line"> 131 			this_cpu_dec(*sem-&gt;read_count);</div><div class="source-line"> 132 			rcuwait_wake_up(&amp;sem-&gt;writer);</div><div class="source-line"> 133 		}</div><div class="source-line current-line">&gt;134&lt;		preempt_enable();</div><div class="source-line"> 135 	}</div><div class="source-line"> 136</div><div class="source-line"> 137 	extern bool percpu_is_read_locked(struct percpu_rw_semaphore *);</div><div class="source-line"> 138 	extern void percpu_down_write(struct percpu_rw_semaphore *);</div><div class="source-line"> 139 	extern void percpu_up_write(struct percpu_rw_semaphore *);</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/fs/super.h#L14" target="_blank">(inlined&nbsp;by)&nbsp;__sb_end_write&nbsp;at&nbsp;./include/linux/fs/super.h:14</a><div class="source-line"> 9 	 * These are internal functions, please use sb_start_{write,pagefault,intwrite}</div><div class="source-line"> 10 	 * instead.</div><div class="source-line"> 11 	 */</div><div class="source-line"> 12 	static inline void __sb_end_write(struct super_block *sb, int level)</div><div class="source-line"> 13 	{</div><div class="source-line current-line">&gt;14&lt;		percpu_up_read(sb-&gt;s_writers.rw_sem + level - 1);</div><div class="source-line"> 15 	}</div><div class="source-line"> 16</div><div class="source-line"> 17 	static inline void __sb_start_write(struct super_block *sb, int level)</div><div class="source-line"> 18 	{</div><div class="source-line"> 19 		percpu_down_read_freezable(sb-&gt;s_writers.rw_sem + level - 1, true);</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/fs/super.h#L77" target="_blank">(inlined&nbsp;by)&nbsp;sb_end_write&nbsp;at&nbsp;./include/linux/fs/super.h:77</a><div class="source-line"> 72 	 * Decrement number of writers to the filesystem. Wake up possible waiters</div><div class="source-line"> 73 	 * wanting to freeze the filesystem.</div><div class="source-line"> 74 	 */</div><div class="source-line"> 75 	static inline void sb_end_write(struct super_block *sb)</div><div class="source-line"> 76 	{</div><div class="source-line current-line">&gt;77&lt;		__sb_end_write(sb, SB_FREEZE_WRITE);</div><div class="source-line"> 78 	}</div><div class="source-line"> 79</div><div class="source-line"> 80 	/**</div><div class="source-line"> 81 	 * sb_end_pagefault - drop write access to a superblock from a page fault</div><div class="source-line"> 82 	 * @sb: the super we wrote to</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/fs.h#L2701" target="_blank">(inlined&nbsp;by)&nbsp;file_end_write&nbsp;at&nbsp;./include/linux/fs.h:2701</a><div class="source-line"> 2696 	 */</div><div class="source-line"> 2697 	static inline void file_end_write(struct file *file)</div><div class="source-line"> 2698 	{</div><div class="source-line"> 2699 		if (!S_ISREG(file_inode(file)-&gt;i_mode))</div><div class="source-line"> 2700 			return;</div><div class="source-line current-line">&gt;2701&lt;		sb_end_write(file_inode(file)-&gt;i_sb);</div><div class="source-line"> 2702 	}</div><div class="source-line"> 2703</div><div class="source-line"> 2704 	/**</div><div class="source-line"> 2705 	 * kiocb_start_write - get write access to a superblock for async file io</div><div class="source-line"> 2706 	 * @iocb: the io context we want to submit the write with</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/read_write.c#L694" target="_blank">(inlined&nbsp;by)&nbsp;vfs_write&nbsp;at&nbsp;fs/read_write.c:694</a><div class="source-line"> 689 		if (ret &gt; 0) {</div><div class="source-line"> 690 			fsnotify_modify(file);</div><div class="source-line"> 691 			add_wchar(current, ret);</div><div class="source-line"> 692 		}</div><div class="source-line"> 693 		inc_syscw(current);</div><div class="source-line current-line">&gt;694&lt;		file_end_write(file);</div><div class="source-line"> 695 		return ret;</div><div class="source-line"> 696 	}</div><div class="source-line"> 697</div><div class="source-line"> 698 	/* file_ppos returns &amp;file-&gt;f_pos or NULL if file is stream */</div><div class="source-line"> 699 	static inline loff_t *file_ppos(struct file *file)</div><div style="height: 10px;"></div></div><div class="line-container" id="line_9_container"><span class="line-number">10</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.082&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;fpregs_assert_state_consistent();&nbsp;/*&nbsp;&lt;-do_syscall_64+0xcd/0xf80&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_9')">+</span></div><div class="expanded-content" id="line_9_content"><div class="source-line">Error: No output for function do_syscall_64+0xcc/0xf80</div></div><div class="line-container" id="line_10_container"><span class="line-number">11</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;__x64_sys_dup2()&nbsp;{&nbsp;/*&nbsp;&lt;-do_syscall_64+0x6b/0xf80&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_10')">+</span></div><div class="expanded-content" id="line_10_content"><div class="source-line">Error: No output for function do_syscall_64+0x6a/0xf80</div></div><div class="line-container" id="line_11_container"><span class="line-number">12</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;ksys_dup3()&nbsp;{&nbsp;/*&nbsp;&lt;-__x64_sys_dup2+0x2b/0x230&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_11')">+</span></div><div class="expanded-content" id="line_11_content"><div class="location-link"><strong>__x64_sys_dup2+0x2a/0x230:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/file.c#L1474" target="_blank">__do_sys_dup2&nbsp;at&nbsp;fs/file.c:1474</a><div class="source-line"> 1469 			rcu_read_unlock();</div><div class="source-line"> 1470 			if (f)</div><div class="source-line"> 1471 				fput(f);</div><div class="source-line"> 1472 			return retval;</div><div class="source-line"> 1473 		}</div><div class="source-line current-line">&gt;1474&lt;		return ksys_dup3(oldfd, newfd, 0);</div><div class="source-line"> 1475 	}</div><div class="source-line"> 1476</div><div class="source-line"> 1477 	SYSCALL_DEFINE1(dup, unsigned int, fildes)</div><div class="source-line"> 1478 	{</div><div class="source-line"> 1479 		int ret = -EBADF;</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/file.c#L1458" target="_blank">(inlined&nbsp;by)&nbsp;__se_sys_dup2&nbsp;at&nbsp;fs/file.c:1458</a><div class="source-line"> 1453 	SYSCALL_DEFINE3(dup3, unsigned int, oldfd, unsigned int, newfd, int, flags)</div><div class="source-line"> 1454 	{</div><div class="source-line"> 1455 		return ksys_dup3(oldfd, newfd, flags);</div><div class="source-line"> 1456 	}</div><div class="source-line"> 1457</div><div class="source-line current-line">&gt;1458&lt;	SYSCALL_DEFINE2(dup2, unsigned int, oldfd, unsigned int, newfd)</div><div class="source-line"> 1459 	{</div><div class="source-line"> 1460 		if (unlikely(newfd == oldfd)) { /* corner case */</div><div class="source-line"> 1461 			struct files_struct *files = current-&gt;files;</div><div class="source-line"> 1462 			struct file *f;</div><div class="source-line"> 1463 			int retval = oldfd;</div><div style="height: 10px;"></div></div><div class="line-container" id="line_12_container"><span class="line-number">13</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_raw_spin_lock()&nbsp;{&nbsp;/*&nbsp;&lt;-ksys_dup3+0x62/0x160&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_12')">+</span></div><div class="expanded-content" id="line_12_content"><div class="location-link"><strong>ksys_dup3+0x61/0x160:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/spinlock.h#L351" target="_blank">spin_lock&nbsp;at&nbsp;./include/linux/spinlock.h:351</a><div class="source-line"> 346</div><div class="source-line"> 347 	#endif</div><div class="source-line"> 348</div><div class="source-line"> 349 	static __always_inline void spin_lock(spinlock_t *lock)</div><div class="source-line"> 350 	{</div><div class="source-line current-line">&gt;351&lt;		raw_spin_lock(&amp;lock-&gt;rlock);</div><div class="source-line"> 352 	}</div><div class="source-line"> 353</div><div class="source-line"> 354 	static __always_inline void spin_lock_bh(spinlock_t *lock)</div><div class="source-line"> 355 	{</div><div class="source-line"> 356 		raw_spin_lock_bh(&amp;lock-&gt;rlock);</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/file.c#L1434" target="_blank">(inlined&nbsp;by)&nbsp;ksys_dup3&nbsp;at&nbsp;fs/file.c:1434</a><div class="source-line"> 1429 			return -EINVAL;</div><div class="source-line"> 1430</div><div class="source-line"> 1431 		if (newfd &gt;= rlimit(RLIMIT_NOFILE))</div><div class="source-line"> 1432 			return -EBADF;</div><div class="source-line"> 1433</div><div class="source-line current-line">&gt;1434&lt;		spin_lock(&amp;files-&gt;file_lock);</div><div class="source-line"> 1435 		err = expand_files(files, newfd);</div><div class="source-line"> 1436 		file = files_lookup_fd_locked(files, oldfd);</div><div class="source-line"> 1437 		if (unlikely(!file))</div><div class="source-line"> 1438 			goto Ebadf;</div><div class="source-line"> 1439 		if (unlikely(err &lt; 0)) {</div><div style="height: 10px;"></div></div><div class="line-container" id="line_13_container"><span class="line-number">14</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.085&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preempt_count_add();&nbsp;/*&nbsp;&lt;-_raw_spin_lock+0x17/0x40&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_13')">+</span></div><div class="expanded-content" id="line_13_content"><div class="location-link"><strong>_raw_spin_lock+0x16/0x40:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/spinlock_api_smp.h#L132" target="_blank">__raw_spin_lock&nbsp;at&nbsp;./include/linux/spinlock_api_smp.h:132</a><div class="source-line"> 127 		LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</div><div class="source-line"> 128 	}</div><div class="source-line"> 129</div><div class="source-line"> 130 	static inline void __raw_spin_lock(raw_spinlock_t *lock)</div><div class="source-line"> 131 	{</div><div class="source-line current-line">&gt;132&lt;		preempt_disable();</div><div class="source-line"> 133 		spin_acquire(&amp;lock-&gt;dep_map, 0, 0, _RET_IP_);</div><div class="source-line"> 134 		LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</div><div class="source-line"> 135 	}</div><div class="source-line"> 136</div><div class="source-line"> 137 	#endif /* !CONFIG_GENERIC_LOCKBREAK || CONFIG_DEBUG_LOCK_ALLOC */</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/locking/spinlock.c#L154" target="_blank">(inlined&nbsp;by)&nbsp;_raw_spin_lock&nbsp;at&nbsp;kernel/locking/spinlock.c:154</a><div class="source-line"> 149 	#endif</div><div class="source-line"> 150</div><div class="source-line"> 151 	#ifndef CONFIG_INLINE_SPIN_LOCK</div><div class="source-line"> 152 	noinline void __lockfunc _raw_spin_lock(raw_spinlock_t *lock)</div><div class="source-line"> 153 	{</div><div class="source-line current-line">&gt;154&lt;		__raw_spin_lock(lock);</div><div class="source-line"> 155 	}</div><div class="source-line"> 156 	EXPORT_SYMBOL(_raw_spin_lock);</div><div class="source-line"> 157 	#endif</div><div class="source-line"> 158</div><div class="source-line"> 159 	#ifndef CONFIG_INLINE_SPIN_LOCK_IRQSAVE</div><div style="height: 10px;"></div></div><div class="line-container" id="line_14_container"><span class="line-number">15</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.088&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do_raw_spin_lock();&nbsp;/*&nbsp;&lt;-ksys_dup3+0x62/0x160&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_14')">+</span></div><div class="expanded-content" id="line_14_content"><div class="location-link"><strong>ksys_dup3+0x61/0x160:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/spinlock.h#L351" target="_blank">spin_lock&nbsp;at&nbsp;./include/linux/spinlock.h:351</a><div class="source-line"> 346</div><div class="source-line"> 347 	#endif</div><div class="source-line"> 348</div><div class="source-line"> 349 	static __always_inline void spin_lock(spinlock_t *lock)</div><div class="source-line"> 350 	{</div><div class="source-line current-line">&gt;351&lt;		raw_spin_lock(&amp;lock-&gt;rlock);</div><div class="source-line"> 352 	}</div><div class="source-line"> 353</div><div class="source-line"> 354 	static __always_inline void spin_lock_bh(spinlock_t *lock)</div><div class="source-line"> 355 	{</div><div class="source-line"> 356 		raw_spin_lock_bh(&amp;lock-&gt;rlock);</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/file.c#L1434" target="_blank">(inlined&nbsp;by)&nbsp;ksys_dup3&nbsp;at&nbsp;fs/file.c:1434</a><div class="source-line"> 1429 			return -EINVAL;</div><div class="source-line"> 1430</div><div class="source-line"> 1431 		if (newfd &gt;= rlimit(RLIMIT_NOFILE))</div><div class="source-line"> 1432 			return -EBADF;</div><div class="source-line"> 1433</div><div class="source-line current-line">&gt;1434&lt;		spin_lock(&amp;files-&gt;file_lock);</div><div class="source-line"> 1435 		err = expand_files(files, newfd);</div><div class="source-line"> 1436 		file = files_lookup_fd_locked(files, oldfd);</div><div class="source-line"> 1437 		if (unlikely(!file))</div><div class="source-line"> 1438 			goto Ebadf;</div><div class="source-line"> 1439 		if (unlikely(err &lt; 0)) {</div><div style="height: 10px;"></div></div><div class="line-container" id="line_15_container"><span class="line-number">16</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.447&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;_raw_spin_lock&nbsp;*/</span></div><div class="line-container" id="line_16_container"><span class="line-number">17</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.081&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expand_files();&nbsp;/*&nbsp;&lt;-ksys_dup3+0x6d/0x160&nbsp;ret=0&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_16')">+</span></div><div class="expanded-content" id="line_16_content"><div class="location-link"><strong>ksys_dup3+0x6c/0x160:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/file.c#L1435" target="_blank">ksys_dup3&nbsp;at&nbsp;fs/file.c:1435</a><div class="source-line"> 1430</div><div class="source-line"> 1431 		if (newfd &gt;= rlimit(RLIMIT_NOFILE))</div><div class="source-line"> 1432 			return -EBADF;</div><div class="source-line"> 1433</div><div class="source-line"> 1434 		spin_lock(&amp;files-&gt;file_lock);</div><div class="source-line current-line">&gt;1435&lt;		err = expand_files(files, newfd);</div><div class="source-line"> 1436 		file = files_lookup_fd_locked(files, oldfd);</div><div class="source-line"> 1437 		if (unlikely(!file))</div><div class="source-line"> 1438 			goto Ebadf;</div><div class="source-line"> 1439 		if (unlikely(err &lt; 0)) {</div><div class="source-line"> 1440 			if (err == -EMFILE)</div><div style="height: 10px;"></div></div><div class="line-container" id="line_17_container"><span class="line-number">18</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do_dup2()&nbsp;{&nbsp;/*&nbsp;&lt;-__x64_sys_dup2+0x2b/0x230&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_17')">+</span></div><div class="expanded-content" id="line_17_content"><div class="location-link"><strong>__x64_sys_dup2+0x2a/0x230:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/file.c#L1474" target="_blank">__do_sys_dup2&nbsp;at&nbsp;fs/file.c:1474</a><div class="source-line"> 1469 			rcu_read_unlock();</div><div class="source-line"> 1470 			if (f)</div><div class="source-line"> 1471 				fput(f);</div><div class="source-line"> 1472 			return retval;</div><div class="source-line"> 1473 		}</div><div class="source-line current-line">&gt;1474&lt;		return ksys_dup3(oldfd, newfd, 0);</div><div class="source-line"> 1475 	}</div><div class="source-line"> 1476</div><div class="source-line"> 1477 	SYSCALL_DEFINE1(dup, unsigned int, fildes)</div><div class="source-line"> 1478 	{</div><div class="source-line"> 1479 		int ret = -EBADF;</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/file.c#L1458" target="_blank">(inlined&nbsp;by)&nbsp;__se_sys_dup2&nbsp;at&nbsp;fs/file.c:1458</a><div class="source-line"> 1453 	SYSCALL_DEFINE3(dup3, unsigned int, oldfd, unsigned int, newfd, int, flags)</div><div class="source-line"> 1454 	{</div><div class="source-line"> 1455 		return ksys_dup3(oldfd, newfd, flags);</div><div class="source-line"> 1456 	}</div><div class="source-line"> 1457</div><div class="source-line current-line">&gt;1458&lt;	SYSCALL_DEFINE2(dup2, unsigned int, oldfd, unsigned int, newfd)</div><div class="source-line"> 1459 	{</div><div class="source-line"> 1460 		if (unlikely(newfd == oldfd)) { /* corner case */</div><div class="source-line"> 1461 			struct files_struct *files = current-&gt;files;</div><div class="source-line"> 1462 			struct file *f;</div><div class="source-line"> 1463 			int retval = oldfd;</div><div style="height: 10px;"></div></div><div class="line-container" id="line_18_container"><span class="line-number">19</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_raw_spin_unlock()&nbsp;{&nbsp;/*&nbsp;&lt;-do_dup2+0xaf/0x1b0&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_18')">+</span></div><div class="expanded-content" id="line_18_content"><div class="location-link"><strong>do_dup2+0xae/0x1b0:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/spinlock.h#L391" target="_blank">spin_unlock&nbsp;at&nbsp;./include/linux/spinlock.h:391</a><div class="source-line"> 386 		raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \</div><div class="source-line"> 387 	} while (0)</div><div class="source-line"> 388</div><div class="source-line"> 389 	static __always_inline void spin_unlock(spinlock_t *lock)</div><div class="source-line"> 390 	{</div><div class="source-line current-line">&gt;391&lt;		raw_spin_unlock(&amp;lock-&gt;rlock);</div><div class="source-line"> 392 	}</div><div class="source-line"> 393</div><div class="source-line"> 394 	static __always_inline void spin_unlock_bh(spinlock_t *lock)</div><div class="source-line"> 395 	{</div><div class="source-line"> 396 		raw_spin_unlock_bh(&amp;lock-&gt;rlock);</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/file.c#L1329" target="_blank">(inlined&nbsp;by)&nbsp;do_dup2&nbsp;at&nbsp;fs/file.c:1329</a><div class="source-line"> 1324 		if (!tofree &amp;&amp; fd_is_open(fd, fdt))</div><div class="source-line"> 1325 			goto Ebusy;</div><div class="source-line"> 1326 		get_file(file);</div><div class="source-line"> 1327 		rcu_assign_pointer(fdt-&gt;fd[fd], file);</div><div class="source-line"> 1328 		__set_open_fd(fd, fdt, flags &amp; O_CLOEXEC);</div><div class="source-line current-line">&gt;1329&lt;		spin_unlock(&amp;files-&gt;file_lock);</div><div class="source-line"> 1330</div><div class="source-line"> 1331 		if (tofree)</div><div class="source-line"> 1332 			filp_close(tofree, files);</div><div class="source-line"> 1333</div><div class="source-line"> 1334 		return fd;</div><div style="height: 10px;"></div></div><div class="line-container" id="line_19_container"><span class="line-number">20</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.076&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do_raw_spin_unlock();&nbsp;/*&nbsp;&lt;-_raw_spin_unlock+0x23/0x50&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_19')">+</span></div><div class="expanded-content" id="line_19_content"><div class="location-link"><strong>_raw_spin_unlock+0x22/0x50:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/spinlock_api_smp.h#L142" target="_blank">__raw_spin_unlock&nbsp;at&nbsp;./include/linux/spinlock_api_smp.h:142</a><div class="source-line"> 137 	#endif /* !CONFIG_GENERIC_LOCKBREAK || CONFIG_DEBUG_LOCK_ALLOC */</div><div class="source-line"> 138</div><div class="source-line"> 139 	static inline void __raw_spin_unlock(raw_spinlock_t *lock)</div><div class="source-line"> 140 	{</div><div class="source-line"> 141 		spin_release(&amp;lock-&gt;dep_map, _RET_IP_);</div><div class="source-line current-line">&gt;142&lt;		do_raw_spin_unlock(lock);</div><div class="source-line"> 143 		preempt_enable();</div><div class="source-line"> 144 	}</div><div class="source-line"> 145</div><div class="source-line"> 146 	static inline void __raw_spin_unlock_irqrestore(raw_spinlock_t *lock,</div><div class="source-line"> 147 						    unsigned long flags)</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/locking/spinlock.c#L186" target="_blank">(inlined&nbsp;by)&nbsp;_raw_spin_unlock&nbsp;at&nbsp;kernel/locking/spinlock.c:186</a><div class="source-line"> 181 	#endif</div><div class="source-line"> 182</div><div class="source-line"> 183 	#ifdef CONFIG_UNINLINE_SPIN_UNLOCK</div><div class="source-line"> 184 	noinline void __lockfunc _raw_spin_unlock(raw_spinlock_t *lock)</div><div class="source-line"> 185 	{</div><div class="source-line current-line">&gt;186&lt;		__raw_spin_unlock(lock);</div><div class="source-line"> 187 	}</div><div class="source-line"> 188 	EXPORT_SYMBOL(_raw_spin_unlock);</div><div class="source-line"> 189 	#endif</div><div class="source-line"> 190</div><div class="source-line"> 191 	#ifndef CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE</div><div style="height: 10px;"></div></div><div class="line-container" id="line_20_container"><span class="line-number">21</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.079&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preempt_count_sub();&nbsp;/*&nbsp;&lt;-_raw_spin_unlock+0x2d/0x50&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_20')">+</span></div><div class="expanded-content" id="line_20_content"><div class="location-link"><strong>_raw_spin_unlock+0x2c/0x50:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/spinlock_api_smp.h#L143" target="_blank">__raw_spin_unlock&nbsp;at&nbsp;./include/linux/spinlock_api_smp.h:143</a><div class="source-line"> 138</div><div class="source-line"> 139 	static inline void __raw_spin_unlock(raw_spinlock_t *lock)</div><div class="source-line"> 140 	{</div><div class="source-line"> 141 		spin_release(&amp;lock-&gt;dep_map, _RET_IP_);</div><div class="source-line"> 142 		do_raw_spin_unlock(lock);</div><div class="source-line current-line">&gt;143&lt;		preempt_enable();</div><div class="source-line"> 144 	}</div><div class="source-line"> 145</div><div class="source-line"> 146 	static inline void __raw_spin_unlock_irqrestore(raw_spinlock_t *lock,</div><div class="source-line"> 147 						    unsigned long flags)</div><div class="source-line"> 148 	{</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/locking/spinlock.c#L186" target="_blank">(inlined&nbsp;by)&nbsp;_raw_spin_unlock&nbsp;at&nbsp;kernel/locking/spinlock.c:186</a><div class="source-line"> 181 	#endif</div><div class="source-line"> 182</div><div class="source-line"> 183 	#ifdef CONFIG_UNINLINE_SPIN_UNLOCK</div><div class="source-line"> 184 	noinline void __lockfunc _raw_spin_unlock(raw_spinlock_t *lock)</div><div class="source-line"> 185 	{</div><div class="source-line current-line">&gt;186&lt;		__raw_spin_unlock(lock);</div><div class="source-line"> 187 	}</div><div class="source-line"> 188 	EXPORT_SYMBOL(_raw_spin_unlock);</div><div class="source-line"> 189 	#endif</div><div class="source-line"> 190</div><div class="source-line"> 191 	#ifndef CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE</div><div style="height: 10px;"></div></div><div class="line-container" id="line_21_container"><span class="line-number">22</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.397&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;_raw_spin_unlock&nbsp;*/</span></div><div class="line-container" id="line_22_container"><span class="line-number">23</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filp_close()&nbsp;{&nbsp;/*&nbsp;&lt;-do_dup2+0xbf/0x1b0&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_22')">+</span></div><div class="expanded-content" id="line_22_content"><div class="location-link"><strong>do_dup2+0xbe/0x1b0:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/file.c#L1332" target="_blank">do_dup2&nbsp;at&nbsp;fs/file.c:1332</a><div class="source-line"> 1327 		rcu_assign_pointer(fdt-&gt;fd[fd], file);</div><div class="source-line"> 1328 		__set_open_fd(fd, fdt, flags &amp; O_CLOEXEC);</div><div class="source-line"> 1329 		spin_unlock(&amp;files-&gt;file_lock);</div><div class="source-line"> 1330</div><div class="source-line"> 1331 		if (tofree)</div><div class="source-line current-line">&gt;1332&lt;			filp_close(tofree, files);</div><div class="source-line"> 1333</div><div class="source-line"> 1334 		return fd;</div><div class="source-line"> 1335</div><div class="source-line"> 1336 	Ebusy:</div><div class="source-line"> 1337 		spin_unlock(&amp;files-&gt;file_lock);</div><div style="height: 10px;"></div></div><div class="line-container" id="line_23_container"><span class="line-number">24</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filp_flush()&nbsp;{&nbsp;/*&nbsp;&lt;-filp_close+0x14/0x30&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_23')">+</span></div><div class="expanded-content" id="line_23_content"><div class="location-link"><strong>filp_close+0x13/0x30:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/open.c#L1546" target="_blank">filp_close&nbsp;at&nbsp;fs/open.c:1546</a><div class="source-line"> 1541</div><div class="source-line"> 1542 	int filp_close(struct file *filp, fl_owner_t id)</div><div class="source-line"> 1543 	{</div><div class="source-line"> 1544 		int retval;</div><div class="source-line"> 1545</div><div class="source-line current-line">&gt;1546&lt;		retval = filp_flush(filp, id);</div><div class="source-line"> 1547 		fput_close(filp);</div><div class="source-line"> 1548</div><div class="source-line"> 1549 		return retval;</div><div class="source-line"> 1550 	}</div><div class="source-line"> 1551 	EXPORT_SYMBOL(filp_close);</div><div style="height: 10px;"></div></div><div class="line-container" id="line_24_container"><span class="line-number">25</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.074&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dnotify_flush();&nbsp;/*&nbsp;&lt;-filp_flush+0x79/0xa0&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_24')">+</span></div><div class="expanded-content" id="line_24_content"><div class="location-link"><strong>filp_flush+0x78/0xa0:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/open.c#L1536" target="_blank">filp_flush&nbsp;at&nbsp;fs/open.c:1536</a><div class="source-line"> 1531</div><div class="source-line"> 1532 		if (filp-&gt;f_op-&gt;flush)</div><div class="source-line"> 1533 			retval = filp-&gt;f_op-&gt;flush(filp, id);</div><div class="source-line"> 1534</div><div class="source-line"> 1535 		if (likely(!(filp-&gt;f_mode &amp; FMODE_PATH))) {</div><div class="source-line current-line">&gt;1536&lt;			dnotify_flush(filp, id);</div><div class="source-line"> 1537 			locks_remove_posix(filp, id);</div><div class="source-line"> 1538 		}</div><div class="source-line"> 1539 		return retval;</div><div class="source-line"> 1540 	}</div><div class="source-line"> 1541</div><div style="height: 10px;"></div></div><div class="line-container" id="line_25_container"><span class="line-number">26</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.072&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;locks_remove_posix();&nbsp;/*&nbsp;&lt;-filp_flush+0x84/0xa0&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_25')">+</span></div><div class="expanded-content" id="line_25_content"><div class="location-link"><strong>filp_flush+0x83/0xa0:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/open.c#L1537" target="_blank">filp_flush&nbsp;at&nbsp;fs/open.c:1537</a><div class="source-line"> 1532 		if (filp-&gt;f_op-&gt;flush)</div><div class="source-line"> 1533 			retval = filp-&gt;f_op-&gt;flush(filp, id);</div><div class="source-line"> 1534</div><div class="source-line"> 1535 		if (likely(!(filp-&gt;f_mode &amp; FMODE_PATH))) {</div><div class="source-line"> 1536 			dnotify_flush(filp, id);</div><div class="source-line current-line">&gt;1537&lt;			locks_remove_posix(filp, id);</div><div class="source-line"> 1538 		}</div><div class="source-line"> 1539 		return retval;</div><div class="source-line"> 1540 	}</div><div class="source-line"> 1541</div><div class="source-line"> 1542 	int filp_close(struct file *filp, fl_owner_t id)</div><div style="height: 10px;"></div></div><div class="line-container" id="line_26_container"><span class="line-number">27</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.376&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;filp_flush&nbsp;ret=0&nbsp;*/</span></div><div class="line-container" id="line_27_container"><span class="line-number">28</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fput_close()&nbsp;{&nbsp;/*&nbsp;&lt;-filp_close+0x1f/0x30&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_27')">+</span></div><div class="expanded-content" id="line_27_content"><div class="location-link"><strong>filp_close+0x1e/0x30:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/open.c#L1547" target="_blank">filp_close&nbsp;at&nbsp;fs/open.c:1547</a><div class="source-line"> 1542 	int filp_close(struct file *filp, fl_owner_t id)</div><div class="source-line"> 1543 	{</div><div class="source-line"> 1544 		int retval;</div><div class="source-line"> 1545</div><div class="source-line"> 1546 		retval = filp_flush(filp, id);</div><div class="source-line current-line">&gt;1547&lt;		fput_close(filp);</div><div class="source-line"> 1548</div><div class="source-line"> 1549 		return retval;</div><div class="source-line"> 1550 	}</div><div class="source-line"> 1551 	EXPORT_SYMBOL(filp_close);</div><div class="source-line"> 1552</div><div style="height: 10px;"></div></div><div class="line-container" id="line_28_container"><span class="line-number">29</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__fput_deferred()&nbsp;{&nbsp;/*&nbsp;&lt;-filp_close+0x1f/0x30&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_28')">+</span></div><div class="expanded-content" id="line_28_content"><div class="location-link"><strong>filp_close+0x1e/0x30:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/open.c#L1547" target="_blank">filp_close&nbsp;at&nbsp;fs/open.c:1547</a><div class="source-line"> 1542 	int filp_close(struct file *filp, fl_owner_t id)</div><div class="source-line"> 1543 	{</div><div class="source-line"> 1544 		int retval;</div><div class="source-line"> 1545</div><div class="source-line"> 1546 		retval = filp_flush(filp, id);</div><div class="source-line current-line">&gt;1547&lt;		fput_close(filp);</div><div class="source-line"> 1548</div><div class="source-line"> 1549 		return retval;</div><div class="source-line"> 1550 	}</div><div class="source-line"> 1551 	EXPORT_SYMBOL(filp_close);</div><div class="source-line"> 1552</div><div style="height: 10px;"></div></div><div class="line-container" id="line_29_container"><span class="line-number">30</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;task_work_add()&nbsp;{&nbsp;/*&nbsp;&lt;-__fput_deferred+0x4d/0x110&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_29')">+</span></div><div class="expanded-content" id="line_29_content"><div class="location-link"><strong>__fput_deferred+0x4c/0x110:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/file_table.c#L529" target="_blank">__fput_deferred&nbsp;at&nbsp;fs/file_table.c:529</a><div class="source-line"> 524 			return;</div><div class="source-line"> 525 		}</div><div class="source-line"> 526</div><div class="source-line"> 527 		if (likely(!in_interrupt() &amp;&amp; !(task-&gt;flags &amp; PF_KTHREAD))) {</div><div class="source-line"> 528 			init_task_work(&amp;file-&gt;f_task_work, ____fput);</div><div class="source-line current-line">&gt;529&lt;			if (!task_work_add(task, &amp;file-&gt;f_task_work, TWA_RESUME))</div><div class="source-line"> 530 				return;</div><div class="source-line"> 531 			/*</div><div class="source-line"> 532 			 * After this task has run exit_task_work(),</div><div class="source-line"> 533 			 * task_work_add() will fail.  Fall through to delayed</div><div class="source-line"> 534 			 * fput to avoid leaking *file.</div><div style="height: 10px;"></div></div><div class="line-container" id="line_30_container"><span class="line-number">31</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.083&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kick_process();&nbsp;/*&nbsp;&lt;-task_work_add+0x86/0x100&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_30')">+</span></div><div class="expanded-content" id="line_30_content"><div class="location-link"><strong>task_work_add+0x85/0x100:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/resume_user_mode.h#L24" target="_blank">set_notify_resume&nbsp;at&nbsp;./include/linux/resume_user_mode.h:24</a><div class="source-line"> 19 	 * If it's blocked, it will not be woken.</div><div class="source-line"> 20 	 */</div><div class="source-line"> 21 	static inline void set_notify_resume(struct task_struct *task)</div><div class="source-line"> 22 	{</div><div class="source-line"> 23 		if (!test_and_set_tsk_thread_flag(task, TIF_NOTIFY_RESUME))</div><div class="source-line current-line">&gt;24&lt;			kick_process(task);</div><div class="source-line"> 25 	}</div><div class="source-line"> 26</div><div class="source-line"> 27</div><div class="source-line"> 28 	/**</div><div class="source-line"> 29 	 * resume_user_mode_work - Perform work before returning to user mode</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/task_work.c#L84" target="_blank">(inlined&nbsp;by)&nbsp;task_work_add&nbsp;at&nbsp;kernel/task_work.c:84</a><div class="source-line"> 79</div><div class="source-line"> 80 		switch (notify) {</div><div class="source-line"> 81 		case TWA_NONE:</div><div class="source-line"> 82 			break;</div><div class="source-line"> 83 		case TWA_RESUME:</div><div class="source-line current-line">&gt;84&lt;			set_notify_resume(task);</div><div class="source-line"> 85 			break;</div><div class="source-line"> 86 		case TWA_SIGNAL:</div><div class="source-line"> 87 			set_notify_signal(task);</div><div class="source-line"> 88 			break;</div><div class="source-line"> 89 		case TWA_SIGNAL_NO_IPI:</div><div style="height: 10px;"></div></div><div class="line-container" id="line_31_container"><span class="line-number">32</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.236&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;task_work_add&nbsp;ret=0&nbsp;*/</span></div><div class="line-container" id="line_32_container"><span class="line-number">33</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.402&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;__fput_deferred&nbsp;*/</span></div><div class="line-container" id="line_33_container"><span class="line-number">34</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.556&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;fput_close&nbsp;*/</span></div><div class="line-container" id="line_34_container"><span class="line-number">35</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;1.156&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;filp_close&nbsp;ret=0&nbsp;*/</span></div><div class="line-container" id="line_35_container"><span class="line-number">36</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;1.812&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;do_dup2&nbsp;ret=1&nbsp;*/</span></div><div class="line-container" id="line_36_container"><span class="line-number">37</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;2.666&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;ksys_dup3&nbsp;ret=1&nbsp;*/</span></div><div class="line-container" id="line_37_container"><span class="line-number">38</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;2.824&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;}&nbsp;/*&nbsp;__x64_sys_dup2&nbsp;ret=1&nbsp;*/</span></div><div class="line-container" id="line_38_container"><span class="line-number">39</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;task_work_run()&nbsp;{&nbsp;/*&nbsp;&lt;-exit_to_user_mode_loop+0x12f/0x4b0&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_38')">+</span></div><div class="expanded-content" id="line_38_content"><div class="location-link"><strong>exit_to_user_mode_loop+0x12e/0x4b0:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/resume_user_mode.h#L50" target="_blank">resume_user_mode_work&nbsp;at&nbsp;./include/linux/resume_user_mode.h:50</a><div class="source-line"> 45 		 * This barrier pairs with task_work_add()-&gt;set_notify_resume() after</div><div class="source-line"> 46 		 * hlist_add_head(task-&gt;task_works);</div><div class="source-line"> 47 		 */</div><div class="source-line"> 48 		smp_mb__after_atomic();</div><div class="source-line"> 49 		if (unlikely(task_work_pending(current)))</div><div class="source-line current-line">&gt;50&lt;			task_work_run();</div><div class="source-line"> 51</div><div class="source-line"> 52 	#ifdef CONFIG_KEYS_REQUEST_CACHE</div><div class="source-line"> 53 		if (unlikely(current-&gt;cached_requested_key)) {</div><div class="source-line"> 54 			key_put(current-&gt;cached_requested_key);</div><div class="source-line"> 55 			current-&gt;cached_requested_key = NULL;</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/entry/common.c#L44" target="_blank">(inlined&nbsp;by)&nbsp;__exit_to_user_mode_loop&nbsp;at&nbsp;kernel/entry/common.c:44</a><div class="source-line"> 39</div><div class="source-line"> 40 			if (ti_work &amp; (_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL))</div><div class="source-line"> 41 				arch_do_signal_or_restart(regs);</div><div class="source-line"> 42</div><div class="source-line"> 43 			if (ti_work &amp; _TIF_NOTIFY_RESUME)</div><div class="source-line current-line">&gt;44&lt;				resume_user_mode_work(regs);</div><div class="source-line"> 45</div><div class="source-line"> 46 			/* Architecture specific TIF work */</div><div class="source-line"> 47 			arch_exit_to_user_mode_work(regs, ti_work);</div><div class="source-line"> 48</div><div class="source-line"> 49 			/*</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/entry/common.c#L75" target="_blank">(inlined&nbsp;by)&nbsp;exit_to_user_mode_loop&nbsp;at&nbsp;kernel/entry/common.c:75</a><div class="source-line"> 70 	 */</div><div class="source-line"> 71 	__always_inline unsigned long exit_to_user_mode_loop(struct pt_regs *regs,</div><div class="source-line"> 72 							     unsigned long ti_work)</div><div class="source-line"> 73 	{</div><div class="source-line"> 74 		for (;;) {</div><div class="source-line current-line">&gt;75&lt;			ti_work = __exit_to_user_mode_loop(regs, ti_work);</div><div class="source-line"> 76</div><div class="source-line"> 77 			if (likely(!rseq_exit_to_user_mode_restart(regs, ti_work)))</div><div class="source-line"> 78 				return ti_work;</div><div class="source-line"> 79 			ti_work = read_thread_flags();</div><div class="source-line"> 80 		}</div><div style="height: 10px;"></div></div><div class="line-container" id="line_39_container"><span class="line-number">40</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;_raw_spin_lock_irq()&nbsp;{&nbsp;/*&nbsp;&lt;-task_work_run+0x45/0x90&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_39')">+</span></div><div class="expanded-content" id="line_39_content"><div class="location-link"><strong>task_work_run+0x44/0x90:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/task_work.c#L228" target="_blank">task_work_run&nbsp;at&nbsp;kernel/task_work.c:228</a><div class="source-line"> 223 			/*</div><div class="source-line"> 224 			 * Synchronize with task_work_cancel_match(). It can not remove</div><div class="source-line"> 225 			 * the first entry == work, cmpxchg(task_works) must fail.</div><div class="source-line"> 226 			 * But it can remove another entry from the -&gt;next list.</div><div class="source-line"> 227 			 */</div><div class="source-line current-line">&gt;228&lt;			raw_spin_lock_irq(&amp;task-&gt;pi_lock);</div><div class="source-line"> 229 			raw_spin_unlock_irq(&amp;task-&gt;pi_lock);</div><div class="source-line"> 230</div><div class="source-line"> 231 			do {</div><div class="source-line"> 232 				next = work-&gt;next;</div><div class="source-line"> 233 				work-&gt;func(work);</div><div style="height: 10px;"></div></div><div class="line-container" id="line_40_container"><span class="line-number">41</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.075&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preempt_count_add();&nbsp;/*&nbsp;&lt;-_raw_spin_lock_irq+0x1f/0x50&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_40')">+</span></div><div class="expanded-content" id="line_40_content"><div class="location-link"><strong>_raw_spin_lock_irq+0x1e/0x50:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/spinlock_api_smp.h#L118" target="_blank">__raw_spin_lock_irq&nbsp;at&nbsp;./include/linux/spinlock_api_smp.h:118</a><div class="source-line"> 113 	}</div><div class="source-line"> 114</div><div class="source-line"> 115 	static inline void __raw_spin_lock_irq(raw_spinlock_t *lock)</div><div class="source-line"> 116 	{</div><div class="source-line"> 117 		local_irq_disable();</div><div class="source-line current-line">&gt;118&lt;		preempt_disable();</div><div class="source-line"> 119 		spin_acquire(&amp;lock-&gt;dep_map, 0, 0, _RET_IP_);</div><div class="source-line"> 120 		LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</div><div class="source-line"> 121 	}</div><div class="source-line"> 122</div><div class="source-line"> 123 	static inline void __raw_spin_lock_bh(raw_spinlock_t *lock)</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/locking/spinlock.c#L170" target="_blank">(inlined&nbsp;by)&nbsp;_raw_spin_lock_irq&nbsp;at&nbsp;kernel/locking/spinlock.c:170</a><div class="source-line"> 165 	#endif</div><div class="source-line"> 166</div><div class="source-line"> 167 	#ifndef CONFIG_INLINE_SPIN_LOCK_IRQ</div><div class="source-line"> 168 	noinline void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)</div><div class="source-line"> 169 	{</div><div class="source-line current-line">&gt;170&lt;		__raw_spin_lock_irq(lock);</div><div class="source-line"> 171 	}</div><div class="source-line"> 172 	EXPORT_SYMBOL(_raw_spin_lock_irq);</div><div class="source-line"> 173 	#endif</div><div class="source-line"> 174</div><div class="source-line"> 175 	#ifndef CONFIG_INLINE_SPIN_LOCK_BH</div><div style="height: 10px;"></div></div><div class="line-container" id="line_41_container"><span class="line-number">42</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.082&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do_raw_spin_lock();&nbsp;/*&nbsp;&lt;-task_work_run+0x45/0x90&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_41')">+</span></div><div class="expanded-content" id="line_41_content"><div class="location-link"><strong>task_work_run+0x44/0x90:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/task_work.c#L228" target="_blank">task_work_run&nbsp;at&nbsp;kernel/task_work.c:228</a><div class="source-line"> 223 			/*</div><div class="source-line"> 224 			 * Synchronize with task_work_cancel_match(). It can not remove</div><div class="source-line"> 225 			 * the first entry == work, cmpxchg(task_works) must fail.</div><div class="source-line"> 226 			 * But it can remove another entry from the -&gt;next list.</div><div class="source-line"> 227 			 */</div><div class="source-line current-line">&gt;228&lt;			raw_spin_lock_irq(&amp;task-&gt;pi_lock);</div><div class="source-line"> 229 			raw_spin_unlock_irq(&amp;task-&gt;pi_lock);</div><div class="source-line"> 230</div><div class="source-line"> 231 			do {</div><div class="source-line"> 232 				next = work-&gt;next;</div><div class="source-line"> 233 				work-&gt;func(work);</div><div style="height: 10px;"></div></div><div class="line-container" id="line_42_container"><span class="line-number">43</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.436&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;_raw_spin_lock_irq&nbsp;*/</span></div><div class="line-container" id="line_43_container"><span class="line-number">44</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;_raw_spin_unlock_irq()&nbsp;{&nbsp;/*&nbsp;&lt;-task_work_run+0x4d/0x90&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_43')">+</span></div><div class="expanded-content" id="line_43_content"><div class="location-link"><strong>task_work_run+0x4c/0x90:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/task_work.c#L229" target="_blank">task_work_run&nbsp;at&nbsp;kernel/task_work.c:229</a><div class="source-line"> 224 			 * Synchronize with task_work_cancel_match(). It can not remove</div><div class="source-line"> 225 			 * the first entry == work, cmpxchg(task_works) must fail.</div><div class="source-line"> 226 			 * But it can remove another entry from the -&gt;next list.</div><div class="source-line"> 227 			 */</div><div class="source-line"> 228 			raw_spin_lock_irq(&amp;task-&gt;pi_lock);</div><div class="source-line current-line">&gt;229&lt;			raw_spin_unlock_irq(&amp;task-&gt;pi_lock);</div><div class="source-line"> 230</div><div class="source-line"> 231 			do {</div><div class="source-line"> 232 				next = work-&gt;next;</div><div class="source-line"> 233 				work-&gt;func(work);</div><div class="source-line"> 234 				work = next;</div><div style="height: 10px;"></div></div><div class="line-container" id="line_44_container"><span class="line-number">45</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.075&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do_raw_spin_unlock();&nbsp;/*&nbsp;&lt;-_raw_spin_unlock_irq+0x23/0x50&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_44')">+</span></div><div class="expanded-content" id="line_44_content"><div class="location-link"><strong>_raw_spin_unlock_irq+0x22/0x50:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/spinlock_api_smp.h#L158" target="_blank">__raw_spin_unlock_irq&nbsp;at&nbsp;./include/linux/spinlock_api_smp.h:158</a><div class="source-line"> 153 	}</div><div class="source-line"> 154</div><div class="source-line"> 155 	static inline void __raw_spin_unlock_irq(raw_spinlock_t *lock)</div><div class="source-line"> 156 	{</div><div class="source-line"> 157 		spin_release(&amp;lock-&gt;dep_map, _RET_IP_);</div><div class="source-line current-line">&gt;158&lt;		do_raw_spin_unlock(lock);</div><div class="source-line"> 159 		local_irq_enable();</div><div class="source-line"> 160 		preempt_enable();</div><div class="source-line"> 161 	}</div><div class="source-line"> 162</div><div class="source-line"> 163 	static inline void __raw_spin_unlock_bh(raw_spinlock_t *lock)</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/locking/spinlock.c#L202" target="_blank">(inlined&nbsp;by)&nbsp;_raw_spin_unlock_irq&nbsp;at&nbsp;kernel/locking/spinlock.c:202</a><div class="source-line"> 197 	#endif</div><div class="source-line"> 198</div><div class="source-line"> 199 	#ifndef CONFIG_INLINE_SPIN_UNLOCK_IRQ</div><div class="source-line"> 200 	noinline void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)</div><div class="source-line"> 201 	{</div><div class="source-line current-line">&gt;202&lt;		__raw_spin_unlock_irq(lock);</div><div class="source-line"> 203 	}</div><div class="source-line"> 204 	EXPORT_SYMBOL(_raw_spin_unlock_irq);</div><div class="source-line"> 205 	#endif</div><div class="source-line"> 206</div><div class="source-line"> 207 	#ifndef CONFIG_INLINE_SPIN_UNLOCK_BH</div><div style="height: 10px;"></div></div><div class="line-container" id="line_45_container"><span class="line-number">46</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.080&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preempt_count_sub();&nbsp;/*&nbsp;&lt;-_raw_spin_unlock_irq+0x33/0x50&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_45')">+</span></div><div class="expanded-content" id="line_45_content"><div class="location-link"><strong>_raw_spin_unlock_irq+0x32/0x50:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/spinlock_api_smp.h#L160" target="_blank">__raw_spin_unlock_irq&nbsp;at&nbsp;./include/linux/spinlock_api_smp.h:160</a><div class="source-line"> 155 	static inline void __raw_spin_unlock_irq(raw_spinlock_t *lock)</div><div class="source-line"> 156 	{</div><div class="source-line"> 157 		spin_release(&amp;lock-&gt;dep_map, _RET_IP_);</div><div class="source-line"> 158 		do_raw_spin_unlock(lock);</div><div class="source-line"> 159 		local_irq_enable();</div><div class="source-line current-line">&gt;160&lt;		preempt_enable();</div><div class="source-line"> 161 	}</div><div class="source-line"> 162</div><div class="source-line"> 163 	static inline void __raw_spin_unlock_bh(raw_spinlock_t *lock)</div><div class="source-line"> 164 	{</div><div class="source-line"> 165 		spin_release(&amp;lock-&gt;dep_map, _RET_IP_);</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/locking/spinlock.c#L202" target="_blank">(inlined&nbsp;by)&nbsp;_raw_spin_unlock_irq&nbsp;at&nbsp;kernel/locking/spinlock.c:202</a><div class="source-line"> 197 	#endif</div><div class="source-line"> 198</div><div class="source-line"> 199 	#ifndef CONFIG_INLINE_SPIN_UNLOCK_IRQ</div><div class="source-line"> 200 	noinline void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)</div><div class="source-line"> 201 	{</div><div class="source-line current-line">&gt;202&lt;		__raw_spin_unlock_irq(lock);</div><div class="source-line"> 203 	}</div><div class="source-line"> 204 	EXPORT_SYMBOL(_raw_spin_unlock_irq);</div><div class="source-line"> 205 	#endif</div><div class="source-line"> 206</div><div class="source-line"> 207 	#ifndef CONFIG_INLINE_SPIN_UNLOCK_BH</div><div style="height: 10px;"></div></div><div class="line-container" id="line_46_container"><span class="line-number">47</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.438&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;_raw_spin_unlock_irq&nbsp;*/</span></div><div class="line-container" id="line_47_container"><span class="line-number">48</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;____fput()&nbsp;{&nbsp;/*&nbsp;&lt;-task_work_run+0x5c/0x90&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_47')">+</span></div><div class="expanded-content" id="line_47_content"><div class="location-link"><strong>task_work_run+0x5b/0x90:</strong></div><div class="source-line">task_work_run at /vol_1t/Qemu/x86_64/bpf_next/kernel/task_work.c:233 (discriminator 1)</div><div class="source-line"> 228 			raw_spin_lock_irq(&amp;task-&gt;pi_lock);</div><div class="source-line"> 229 			raw_spin_unlock_irq(&amp;task-&gt;pi_lock);</div><div class="source-line"> 230</div><div class="source-line"> 231 			do {</div><div class="source-line"> 232 				next = work-&gt;next;</div><div class="source-line current-line">&gt;233&lt;				work-&gt;func(work);</div><div class="source-line"> 234 				work = next;</div><div class="source-line"> 235 				cond_resched();</div><div class="source-line"> 236 			} while (work);</div><div class="source-line"> 237 		}</div><div class="source-line"> 238 	}</div><div style="height: 10px;"></div></div><div class="line-container" id="line_48_container"><span class="line-number">49</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__fput()&nbsp;{&nbsp;/*&nbsp;&lt;-task_work_run+0x5c/0x90&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_48')">+</span></div><div class="expanded-content" id="line_48_content"><div class="location-link"><strong>task_work_run+0x5b/0x90:</strong></div><div class="source-line">task_work_run at /vol_1t/Qemu/x86_64/bpf_next/kernel/task_work.c:233 (discriminator 1)</div><div class="source-line"> 228 			raw_spin_lock_irq(&amp;task-&gt;pi_lock);</div><div class="source-line"> 229 			raw_spin_unlock_irq(&amp;task-&gt;pi_lock);</div><div class="source-line"> 230</div><div class="source-line"> 231 			do {</div><div class="source-line"> 232 				next = work-&gt;next;</div><div class="source-line current-line">&gt;233&lt;				work-&gt;func(work);</div><div class="source-line"> 234 				work = next;</div><div class="source-line"> 235 				cond_resched();</div><div class="source-line"> 236 			} while (work);</div><div class="source-line"> 237 		}</div><div class="source-line"> 238 	}</div><div style="height: 10px;"></div></div><div class="line-container" id="line_49_container"><span class="line-number">50</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.070&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__cond_resched();&nbsp;/*&nbsp;&lt;-__fput+0x36/0x2c0&nbsp;ret=0&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_49')">+</span></div><div class="expanded-content" id="line_49_content"><div class="location-link"><strong>__fput+0x35/0x2c0:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/kernel.h#L61" target="_blank">might_resched&nbsp;at&nbsp;./include/linux/kernel.h:61</a><div class="source-line"> 56</div><div class="source-line"> 57 	DECLARE_STATIC_CALL(might_resched, __cond_resched);</div><div class="source-line"> 58</div><div class="source-line"> 59 	static __always_inline void might_resched(void)</div><div class="source-line"> 60 	{</div><div class="source-line current-line">&gt;61&lt;		static_call_mod(might_resched)();</div><div class="source-line"> 62 	}</div><div class="source-line"> 63</div><div class="source-line"> 64 	#elif defined(CONFIG_PREEMPT_DYNAMIC) &amp;&amp; defined(CONFIG_HAVE_PREEMPT_DYNAMIC_KEY)</div><div class="source-line"> 65</div><div class="source-line"> 66 	extern int dynamic_might_resched(void);</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/file_table.c#L452" target="_blank">(inlined&nbsp;by)&nbsp;__fput&nbsp;at&nbsp;fs/file_table.c:452</a><div class="source-line"> 447 		fmode_t mode = file-&gt;f_mode;</div><div class="source-line"> 448</div><div class="source-line"> 449 		if (unlikely(!(file-&gt;f_mode &amp; FMODE_OPENED)))</div><div class="source-line"> 450 			goto out;</div><div class="source-line"> 451</div><div class="source-line current-line">&gt;452&lt;		might_sleep();</div><div class="source-line"> 453</div><div class="source-line"> 454 		fsnotify_close(file);</div><div class="source-line"> 455 		/*</div><div class="source-line"> 456 		 * The function eventpoll_release() should be the first called</div><div class="source-line"> 457 		 * in the file cleanup chain.</div><div style="height: 10px;"></div></div><div class="line-container" id="line_50_container"><span class="line-number">51</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.073&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;locks_remove_file();&nbsp;/*&nbsp;&lt;-__fput+0xc7/0x2c0&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_50')">+</span></div><div class="expanded-content" id="line_50_content"><div class="location-link"><strong>__fput+0xc6/0x2c0:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/file_table.c#L460" target="_blank">__fput&nbsp;at&nbsp;fs/file_table.c:460</a><div class="source-line"> 455 		/*</div><div class="source-line"> 456 		 * The function eventpoll_release() should be the first called</div><div class="source-line"> 457 		 * in the file cleanup chain.</div><div class="source-line"> 458 		 */</div><div class="source-line"> 459 		eventpoll_release(file);</div><div class="source-line current-line">&gt;460&lt;		locks_remove_file(file);</div><div class="source-line"> 461</div><div class="source-line"> 462 		security_file_release(file);</div><div class="source-line"> 463 		if (unlikely(file-&gt;f_flags &amp; FASYNC)) {</div><div class="source-line"> 464 			if (file-&gt;f_op-&gt;fasync)</div><div class="source-line"> 465 				file-&gt;f_op-&gt;fasync(-1, file, 0);</div><div style="height: 10px;"></div></div><div class="line-container" id="line_51_container"><span class="line-number">52</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;security_file_release()&nbsp;{&nbsp;/*&nbsp;&lt;-__fput+0xcf/0x2c0&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_51')">+</span></div><div class="expanded-content" id="line_51_content"><div class="location-link"><strong>__fput+0xce/0x2c0:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/file_table.c#L462" target="_blank">__fput&nbsp;at&nbsp;fs/file_table.c:462</a><div class="source-line"> 457 		 * in the file cleanup chain.</div><div class="source-line"> 458 		 */</div><div class="source-line"> 459 		eventpoll_release(file);</div><div class="source-line"> 460 		locks_remove_file(file);</div><div class="source-line"> 461</div><div class="source-line current-line">&gt;462&lt;		security_file_release(file);</div><div class="source-line"> 463 		if (unlikely(file-&gt;f_flags &amp; FASYNC)) {</div><div class="source-line"> 464 			if (file-&gt;f_op-&gt;fasync)</div><div class="source-line"> 465 				file-&gt;f_op-&gt;fasync(-1, file, 0);</div><div class="source-line"> 466 		}</div><div class="source-line"> 467 		if (file-&gt;f_op-&gt;release)</div><div style="height: 10px;"></div></div><div class="line-container" id="line_52_container"><span class="line-number">53</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.071&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bpf_lsm_file_release();&nbsp;/*&nbsp;&lt;-security_file_release+0x20/0x40&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_52')">+</span></div><div class="expanded-content" id="line_52_content"><div class="location-link"><strong>security_file_release+0x1f/0x40:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/security/security.c#L2398" target="_blank">security_file_release&nbsp;at&nbsp;security/security.c:2398</a><div class="source-line"> 2393 	 *</div><div class="source-line"> 2394 	 * Perform actions before releasing the last reference to a file.</div><div class="source-line"> 2395 	 */</div><div class="source-line"> 2396 	void security_file_release(struct file *file)</div><div class="source-line"> 2397 	{</div><div class="source-line current-line">&gt;2398&lt;		call_void_hook(file_release, file);</div><div class="source-line"> 2399 	}</div><div class="source-line"> 2400</div><div class="source-line"> 2401 	/**</div><div class="source-line"> 2402 	 * security_file_free() - Free a file's LSM blob</div><div class="source-line"> 2403 	 * @file: the file</div><div style="height: 10px;"></div></div><div class="line-container" id="line_53_container"><span class="line-number">54</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.078&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ima_file_free();&nbsp;/*&nbsp;&lt;-security_file_release+0x3d/0x40&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_53')">+</span></div><div class="expanded-content" id="line_53_content"><div class="location-link"><strong>security_file_release+0x3c/0x40:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/security/security.c#L2398" target="_blank">security_file_release&nbsp;at&nbsp;security/security.c:2398</a><div class="source-line"> 2393 	 *</div><div class="source-line"> 2394 	 * Perform actions before releasing the last reference to a file.</div><div class="source-line"> 2395 	 */</div><div class="source-line"> 2396 	void security_file_release(struct file *file)</div><div class="source-line"> 2397 	{</div><div class="source-line current-line">&gt;2398&lt;		call_void_hook(file_release, file);</div><div class="source-line"> 2399 	}</div><div class="source-line"> 2400</div><div class="source-line"> 2401 	/**</div><div class="source-line"> 2402 	 * security_file_free() - Free a file's LSM blob</div><div class="source-line"> 2403 	 * @file: the file</div><div style="height: 10px;"></div></div><div class="line-container" id="line_54_container"><span class="line-number">55</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.382&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;security_file_release&nbsp;*/</span></div><div class="line-container" id="line_55_container"><span class="line-number">56</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutex_lock_nested()&nbsp;{&nbsp;/*&nbsp;&lt;-tracing_release_generic_tr+0x1f/0x60&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_55')">+</span></div><div class="expanded-content" id="line_55_content"><div class="location-link"><strong>tracing_release_generic_tr+0x1e/0x60:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/mutex.h#L253" target="_blank">class_mutex_constructor&nbsp;at&nbsp;./include/linux/mutex.h:253</a><div class="source-line"> 248</div><div class="source-line"> 249 	extern void mutex_unlock(struct mutex *lock);</div><div class="source-line"> 250</div><div class="source-line"> 251 	extern int atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock);</div><div class="source-line"> 252</div><div class="source-line current-line">&gt;253&lt;	DEFINE_GUARD(mutex, struct mutex *, mutex_lock(_T), mutex_unlock(_T))</div><div class="source-line"> 254 	DEFINE_GUARD_COND(mutex, _try, mutex_trylock(_T))</div><div class="source-line"> 255 	DEFINE_GUARD_COND(mutex, _intr, mutex_lock_interruptible(_T), _RET == 0)</div><div class="source-line"> 256</div><div class="source-line"> 257 	extern unsigned long mutex_get_owner(struct mutex *lock);</div><div class="source-line"> 258</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/trace/trace.c#L630" target="_blank">(inlined&nbsp;by)&nbsp;trace_array_put&nbsp;at&nbsp;kernel/trace/trace.c:630</a><div class="source-line"> 625 	void trace_array_put(struct trace_array *this_tr)</div><div class="source-line"> 626 	{</div><div class="source-line"> 627 		if (!this_tr)</div><div class="source-line"> 628 			return;</div><div class="source-line"> 629</div><div class="source-line current-line">&gt;630&lt;		guard(mutex)(&amp;trace_types_lock);</div><div class="source-line"> 631 		__trace_array_put(this_tr);</div><div class="source-line"> 632 	}</div><div class="source-line"> 633 	EXPORT_SYMBOL_GPL(trace_array_put);</div><div class="source-line"> 634</div><div class="source-line"> 635 	int tracing_check_open_get_tr(struct trace_array *tr)</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/trace/trace.c#L4865" target="_blank">(inlined&nbsp;by)&nbsp;tracing_release_generic_tr&nbsp;at&nbsp;kernel/trace/trace.c:4865</a><div class="source-line"> 4860</div><div class="source-line"> 4861 	int tracing_release_generic_tr(struct inode *inode, struct file *file)</div><div class="source-line"> 4862 	{</div><div class="source-line"> 4863 		struct trace_array *tr = inode-&gt;i_private;</div><div class="source-line"> 4864</div><div class="source-line current-line">&gt;4865&lt;		trace_array_put(tr);</div><div class="source-line"> 4866 		return 0;</div><div class="source-line"> 4867 	}</div><div class="source-line"> 4868</div><div class="source-line"> 4869 	static int tracing_single_release_tr(struct inode *inode, struct file *file)</div><div class="source-line"> 4870 	{</div><div style="height: 10px;"></div></div><div class="line-container" id="line_56_container"><span class="line-number">57</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__mutex_lock()&nbsp;{&nbsp;/*&nbsp;&lt;-tracing_release_generic_tr+0x1f/0x60&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_56')">+</span></div><div class="expanded-content" id="line_56_content"><div class="location-link"><strong>tracing_release_generic_tr+0x1e/0x60:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/mutex.h#L253" target="_blank">class_mutex_constructor&nbsp;at&nbsp;./include/linux/mutex.h:253</a><div class="source-line"> 248</div><div class="source-line"> 249 	extern void mutex_unlock(struct mutex *lock);</div><div class="source-line"> 250</div><div class="source-line"> 251 	extern int atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock);</div><div class="source-line"> 252</div><div class="source-line current-line">&gt;253&lt;	DEFINE_GUARD(mutex, struct mutex *, mutex_lock(_T), mutex_unlock(_T))</div><div class="source-line"> 254 	DEFINE_GUARD_COND(mutex, _try, mutex_trylock(_T))</div><div class="source-line"> 255 	DEFINE_GUARD_COND(mutex, _intr, mutex_lock_interruptible(_T), _RET == 0)</div><div class="source-line"> 256</div><div class="source-line"> 257 	extern unsigned long mutex_get_owner(struct mutex *lock);</div><div class="source-line"> 258</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/trace/trace.c#L630" target="_blank">(inlined&nbsp;by)&nbsp;trace_array_put&nbsp;at&nbsp;kernel/trace/trace.c:630</a><div class="source-line"> 625 	void trace_array_put(struct trace_array *this_tr)</div><div class="source-line"> 626 	{</div><div class="source-line"> 627 		if (!this_tr)</div><div class="source-line"> 628 			return;</div><div class="source-line"> 629</div><div class="source-line current-line">&gt;630&lt;		guard(mutex)(&amp;trace_types_lock);</div><div class="source-line"> 631 		__trace_array_put(this_tr);</div><div class="source-line"> 632 	}</div><div class="source-line"> 633 	EXPORT_SYMBOL_GPL(trace_array_put);</div><div class="source-line"> 634</div><div class="source-line"> 635 	int tracing_check_open_get_tr(struct trace_array *tr)</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/trace/trace.c#L4865" target="_blank">(inlined&nbsp;by)&nbsp;tracing_release_generic_tr&nbsp;at&nbsp;kernel/trace/trace.c:4865</a><div class="source-line"> 4860</div><div class="source-line"> 4861 	int tracing_release_generic_tr(struct inode *inode, struct file *file)</div><div class="source-line"> 4862 	{</div><div class="source-line"> 4863 		struct trace_array *tr = inode-&gt;i_private;</div><div class="source-line"> 4864</div><div class="source-line current-line">&gt;4865&lt;		trace_array_put(tr);</div><div class="source-line"> 4866 		return 0;</div><div class="source-line"> 4867 	}</div><div class="source-line"> 4868</div><div class="source-line"> 4869 	static int tracing_single_release_tr(struct inode *inode, struct file *file)</div><div class="source-line"> 4870 	{</div><div style="height: 10px;"></div></div><div class="line-container" id="line_57_container"><span class="line-number">58</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.071&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__cond_resched();&nbsp;/*&nbsp;&lt;-__mutex_lock+0x5e/0x10e0&nbsp;ret=0&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_57')">+</span></div><div class="expanded-content" id="line_57_content"><div class="location-link"><strong>__mutex_lock+0x5d/0x10e0:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/kernel.h#L61" target="_blank">might_resched&nbsp;at&nbsp;./include/linux/kernel.h:61</a><div class="source-line"> 56</div><div class="source-line"> 57 	DECLARE_STATIC_CALL(might_resched, __cond_resched);</div><div class="source-line"> 58</div><div class="source-line"> 59 	static __always_inline void might_resched(void)</div><div class="source-line"> 60 	{</div><div class="source-line current-line">&gt;61&lt;		static_call_mod(might_resched)();</div><div class="source-line"> 62 	}</div><div class="source-line"> 63</div><div class="source-line"> 64 	#elif defined(CONFIG_PREEMPT_DYNAMIC) &amp;&amp; defined(CONFIG_HAVE_PREEMPT_DYNAMIC_KEY)</div><div class="source-line"> 65</div><div class="source-line"> 66 	extern int dynamic_might_resched(void);</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/locking/mutex.c#L591" target="_blank">(inlined&nbsp;by)&nbsp;__mutex_lock_common&nbsp;at&nbsp;kernel/locking/mutex.c:591</a><div class="source-line"> 586 		int ret;</div><div class="source-line"> 587</div><div class="source-line"> 588 		if (!use_ww_ctx)</div><div class="source-line"> 589 			ww_ctx = NULL;</div><div class="source-line"> 590</div><div class="source-line current-line">&gt;591&lt;		might_sleep();</div><div class="source-line"> 592</div><div class="source-line"> 593 		MUTEX_WARN_ON(lock-&gt;magic != lock);</div><div class="source-line"> 594</div><div class="source-line"> 595 		ww = container_of(lock, struct ww_mutex, base);</div><div class="source-line"> 596 		if (ww_ctx) {</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/locking/mutex.c#L776" target="_blank">(inlined&nbsp;by)&nbsp;__mutex_lock&nbsp;at&nbsp;kernel/locking/mutex.c:776</a><div class="source-line"> 771</div><div class="source-line"> 772 	static int __sched</div><div class="source-line"> 773 	__mutex_lock(struct mutex *lock, unsigned int state, unsigned int subclass,</div><div class="source-line"> 774 		     struct lockdep_map *nest_lock, unsigned long ip)</div><div class="source-line"> 775 	{</div><div class="source-line current-line">&gt;776&lt;		return __mutex_lock_common(lock, state, subclass, nest_lock, ip, NULL, false);</div><div class="source-line"> 777 	}</div><div class="source-line"> 778</div><div class="source-line"> 779 	static int __sched</div><div class="source-line"> 780 	__ww_mutex_lock(struct mutex *lock, unsigned int state, unsigned int subclass,</div><div class="source-line"> 781 			unsigned long ip, struct ww_acquire_ctx *ww_ctx)</div><div style="height: 10px;"></div></div><div class="line-container" id="line_58_container"><span class="line-number">59</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.075&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preempt_count_add();&nbsp;/*&nbsp;&lt;-__mutex_lock+0x7c/0x10e0&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_58')">+</span></div><div class="expanded-content" id="line_58_content"><div class="location-link"><strong>__mutex_lock+0x7b/0x10e0:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/locking/mutex.c#L613" target="_blank">__mutex_lock_common&nbsp;at&nbsp;kernel/locking/mutex.c:613</a><div class="source-line"> 608 	#ifdef CONFIG_DEBUG_LOCK_ALLOC</div><div class="source-line"> 609 			nest_lock = &amp;ww_ctx-&gt;dep_map;</div><div class="source-line"> 610 	#endif</div><div class="source-line"> 611 		}</div><div class="source-line"> 612</div><div class="source-line current-line">&gt;613&lt;		preempt_disable();</div><div class="source-line"> 614 		mutex_acquire_nest(&amp;lock-&gt;dep_map, subclass, 0, nest_lock, ip);</div><div class="source-line"> 615</div><div class="source-line"> 616 		trace_contention_begin(lock, LCB_F_MUTEX | LCB_F_SPIN);</div><div class="source-line"> 617 		if (__mutex_trylock(lock) ||</div><div class="source-line"> 618 		    mutex_optimistic_spin(lock, ww_ctx, NULL)) {</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/locking/mutex.c#L776" target="_blank">(inlined&nbsp;by)&nbsp;__mutex_lock&nbsp;at&nbsp;kernel/locking/mutex.c:776</a><div class="source-line"> 771</div><div class="source-line"> 772 	static int __sched</div><div class="source-line"> 773 	__mutex_lock(struct mutex *lock, unsigned int state, unsigned int subclass,</div><div class="source-line"> 774 		     struct lockdep_map *nest_lock, unsigned long ip)</div><div class="source-line"> 775 	{</div><div class="source-line current-line">&gt;776&lt;		return __mutex_lock_common(lock, state, subclass, nest_lock, ip, NULL, false);</div><div class="source-line"> 777 	}</div><div class="source-line"> 778</div><div class="source-line"> 779 	static int __sched</div><div class="source-line"> 780 	__ww_mutex_lock(struct mutex *lock, unsigned int state, unsigned int subclass,</div><div class="source-line"> 781 			unsigned long ip, struct ww_acquire_ctx *ww_ctx)</div><div style="height: 10px;"></div></div><div class="line-container" id="line_59_container"><span class="line-number">60</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.075&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preempt_count_sub();&nbsp;/*&nbsp;&lt;-__mutex_lock+0x13d/0x10e0&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_59')">+</span></div><div class="expanded-content" id="line_59_content"><div class="location-link"><strong>__mutex_lock+0x13c/0x10e0:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/locking/mutex.c#L624" target="_blank">__mutex_lock_common&nbsp;at&nbsp;kernel/locking/mutex.c:624</a><div class="source-line"> 619 			/* got the lock, yay! */</div><div class="source-line"> 620 			lock_acquired(&amp;lock-&gt;dep_map, ip);</div><div class="source-line"> 621 			if (ww_ctx)</div><div class="source-line"> 622 				ww_mutex_set_context_fastpath(ww, ww_ctx);</div><div class="source-line"> 623 			trace_contention_end(lock, 0);</div><div class="source-line current-line">&gt;624&lt;			preempt_enable();</div><div class="source-line"> 625 			return 0;</div><div class="source-line"> 626 		}</div><div class="source-line"> 627</div><div class="source-line"> 628 		raw_spin_lock_irqsave(&amp;lock-&gt;wait_lock, flags);</div><div class="source-line"> 629 		/*</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/locking/mutex.c#L776" target="_blank">(inlined&nbsp;by)&nbsp;__mutex_lock&nbsp;at&nbsp;kernel/locking/mutex.c:776</a><div class="source-line"> 771</div><div class="source-line"> 772 	static int __sched</div><div class="source-line"> 773 	__mutex_lock(struct mutex *lock, unsigned int state, unsigned int subclass,</div><div class="source-line"> 774 		     struct lockdep_map *nest_lock, unsigned long ip)</div><div class="source-line"> 775 	{</div><div class="source-line current-line">&gt;776&lt;		return __mutex_lock_common(lock, state, subclass, nest_lock, ip, NULL, false);</div><div class="source-line"> 777 	}</div><div class="source-line"> 778</div><div class="source-line"> 779 	static int __sched</div><div class="source-line"> 780 	__ww_mutex_lock(struct mutex *lock, unsigned int state, unsigned int subclass,</div><div class="source-line"> 781 			unsigned long ip, struct ww_acquire_ctx *ww_ctx)</div><div style="height: 10px;"></div></div><div class="line-container" id="line_60_container"><span class="line-number">61</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.589&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;__mutex_lock&nbsp;ret=0&nbsp;*/</span></div><div class="line-container" id="line_61_container"><span class="line-number">62</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.733&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;mutex_lock_nested&nbsp;*/</span></div><div class="line-container" id="line_62_container"><span class="line-number">63</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutex_unlock()&nbsp;{&nbsp;/*&nbsp;&lt;-tracing_release_generic_tr+0x50/0x60&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_62')">+</span></div><div class="expanded-content" id="line_62_content"><div class="location-link"><strong>tracing_release_generic_tr+0x4f/0x60:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/mutex.h#L253" target="_blank">class_mutex_destructor&nbsp;at&nbsp;./include/linux/mutex.h:253</a><div class="source-line"> 248</div><div class="source-line"> 249 	extern void mutex_unlock(struct mutex *lock);</div><div class="source-line"> 250</div><div class="source-line"> 251 	extern int atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock);</div><div class="source-line"> 252</div><div class="source-line current-line">&gt;253&lt;	DEFINE_GUARD(mutex, struct mutex *, mutex_lock(_T), mutex_unlock(_T))</div><div class="source-line"> 254 	DEFINE_GUARD_COND(mutex, _try, mutex_trylock(_T))</div><div class="source-line"> 255 	DEFINE_GUARD_COND(mutex, _intr, mutex_lock_interruptible(_T), _RET == 0)</div><div class="source-line"> 256</div><div class="source-line"> 257 	extern unsigned long mutex_get_owner(struct mutex *lock);</div><div class="source-line"> 258</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/trace/trace.c#L630" target="_blank">(inlined&nbsp;by)&nbsp;trace_array_put&nbsp;at&nbsp;kernel/trace/trace.c:630</a><div class="source-line"> 625 	void trace_array_put(struct trace_array *this_tr)</div><div class="source-line"> 626 	{</div><div class="source-line"> 627 		if (!this_tr)</div><div class="source-line"> 628 			return;</div><div class="source-line"> 629</div><div class="source-line current-line">&gt;630&lt;		guard(mutex)(&amp;trace_types_lock);</div><div class="source-line"> 631 		__trace_array_put(this_tr);</div><div class="source-line"> 632 	}</div><div class="source-line"> 633 	EXPORT_SYMBOL_GPL(trace_array_put);</div><div class="source-line"> 634</div><div class="source-line"> 635 	int tracing_check_open_get_tr(struct trace_array *tr)</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/trace/trace.c#L4865" target="_blank">(inlined&nbsp;by)&nbsp;tracing_release_generic_tr&nbsp;at&nbsp;kernel/trace/trace.c:4865</a><div class="source-line"> 4860</div><div class="source-line"> 4861 	int tracing_release_generic_tr(struct inode *inode, struct file *file)</div><div class="source-line"> 4862 	{</div><div class="source-line"> 4863 		struct trace_array *tr = inode-&gt;i_private;</div><div class="source-line"> 4864</div><div class="source-line current-line">&gt;4865&lt;		trace_array_put(tr);</div><div class="source-line"> 4866 		return 0;</div><div class="source-line"> 4867 	}</div><div class="source-line"> 4868</div><div class="source-line"> 4869 	static int tracing_single_release_tr(struct inode *inode, struct file *file)</div><div class="source-line"> 4870 	{</div><div style="height: 10px;"></div></div><div class="line-container" id="line_63_container"><span class="line-number">64</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.085&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__mutex_unlock_slowpath();&nbsp;/*&nbsp;&lt;-tracing_release_generic_tr+0x50/0x60&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_63')">+</span></div><div class="expanded-content" id="line_63_content"><div class="location-link"><strong>tracing_release_generic_tr+0x4f/0x60:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/mutex.h#L253" target="_blank">class_mutex_destructor&nbsp;at&nbsp;./include/linux/mutex.h:253</a><div class="source-line"> 248</div><div class="source-line"> 249 	extern void mutex_unlock(struct mutex *lock);</div><div class="source-line"> 250</div><div class="source-line"> 251 	extern int atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock);</div><div class="source-line"> 252</div><div class="source-line current-line">&gt;253&lt;	DEFINE_GUARD(mutex, struct mutex *, mutex_lock(_T), mutex_unlock(_T))</div><div class="source-line"> 254 	DEFINE_GUARD_COND(mutex, _try, mutex_trylock(_T))</div><div class="source-line"> 255 	DEFINE_GUARD_COND(mutex, _intr, mutex_lock_interruptible(_T), _RET == 0)</div><div class="source-line"> 256</div><div class="source-line"> 257 	extern unsigned long mutex_get_owner(struct mutex *lock);</div><div class="source-line"> 258</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/trace/trace.c#L630" target="_blank">(inlined&nbsp;by)&nbsp;trace_array_put&nbsp;at&nbsp;kernel/trace/trace.c:630</a><div class="source-line"> 625 	void trace_array_put(struct trace_array *this_tr)</div><div class="source-line"> 626 	{</div><div class="source-line"> 627 		if (!this_tr)</div><div class="source-line"> 628 			return;</div><div class="source-line"> 629</div><div class="source-line current-line">&gt;630&lt;		guard(mutex)(&amp;trace_types_lock);</div><div class="source-line"> 631 		__trace_array_put(this_tr);</div><div class="source-line"> 632 	}</div><div class="source-line"> 633 	EXPORT_SYMBOL_GPL(trace_array_put);</div><div class="source-line"> 634</div><div class="source-line"> 635 	int tracing_check_open_get_tr(struct trace_array *tr)</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/trace/trace.c#L4865" target="_blank">(inlined&nbsp;by)&nbsp;tracing_release_generic_tr&nbsp;at&nbsp;kernel/trace/trace.c:4865</a><div class="source-line"> 4860</div><div class="source-line"> 4861 	int tracing_release_generic_tr(struct inode *inode, struct file *file)</div><div class="source-line"> 4862 	{</div><div class="source-line"> 4863 		struct trace_array *tr = inode-&gt;i_private;</div><div class="source-line"> 4864</div><div class="source-line current-line">&gt;4865&lt;		trace_array_put(tr);</div><div class="source-line"> 4866 		return 0;</div><div class="source-line"> 4867 	}</div><div class="source-line"> 4868</div><div class="source-line"> 4869 	static int tracing_single_release_tr(struct inode *inode, struct file *file)</div><div class="source-line"> 4870 	{</div><div style="height: 10px;"></div></div><div class="line-container" id="line_64_container"><span class="line-number">65</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.227&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;mutex_unlock&nbsp;*/</span></div><div class="line-container" id="line_65_container"><span class="line-number">66</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.077&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;module_put();&nbsp;/*&nbsp;&lt;-__fput+0x115/0x2c0&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_65')">+</span></div><div class="expanded-content" id="line_65_content"><div class="location-link"><strong>__fput+0x114/0x2c0:</strong></div><div class="source-line">__fput at /vol_1t/Qemu/x86_64/bpf_next/fs/file_table.c:473 (discriminator 1)</div><div class="source-line"> 468 			file-&gt;f_op-&gt;release(inode, file);</div><div class="source-line"> 469 		if (unlikely(S_ISCHR(inode-&gt;i_mode) &amp;&amp; inode-&gt;i_cdev != NULL &amp;&amp;</div><div class="source-line"> 470 			     !(mode &amp; FMODE_PATH))) {</div><div class="source-line"> 471 			cdev_put(inode-&gt;i_cdev);</div><div class="source-line"> 472 		}</div><div class="source-line current-line">&gt;473&lt;		fops_put(file-&gt;f_op);</div><div class="source-line"> 474 		file_f_owner_release(file);</div><div class="source-line"> 475 		put_file_access(file);</div><div class="source-line"> 476 		dput(dentry);</div><div class="source-line"> 477 		if (unlikely(mode &amp; FMODE_NEED_UNMOUNT))</div><div class="source-line"> 478 			dissolve_on_fput(mnt);</div><div style="height: 10px;"></div></div><div class="line-container" id="line_66_container"><span class="line-number">67</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.072&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file_f_owner_release();&nbsp;/*&nbsp;&lt;-__fput+0x11d/0x2c0&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_66')">+</span></div><div class="expanded-content" id="line_66_content"><div class="location-link"><strong>__fput+0x11c/0x2c0:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/file_table.c#L474" target="_blank">__fput&nbsp;at&nbsp;fs/file_table.c:474</a><div class="source-line"> 469 		if (unlikely(S_ISCHR(inode-&gt;i_mode) &amp;&amp; inode-&gt;i_cdev != NULL &amp;&amp;</div><div class="source-line"> 470 			     !(mode &amp; FMODE_PATH))) {</div><div class="source-line"> 471 			cdev_put(inode-&gt;i_cdev);</div><div class="source-line"> 472 		}</div><div class="source-line"> 473 		fops_put(file-&gt;f_op);</div><div class="source-line current-line">&gt;474&lt;		file_f_owner_release(file);</div><div class="source-line"> 475 		put_file_access(file);</div><div class="source-line"> 476 		dput(dentry);</div><div class="source-line"> 477 		if (unlikely(mode &amp; FMODE_NEED_UNMOUNT))</div><div class="source-line"> 478 			dissolve_on_fput(mnt);</div><div class="source-line"> 479 		mntput(mnt);</div><div style="height: 10px;"></div></div><div class="line-container" id="line_67_container"><span class="line-number">68</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mnt_put_write_access()&nbsp;{&nbsp;/*&nbsp;&lt;-__fput+0x1e7/0x2c0&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_67')">+</span></div><div class="expanded-content" id="line_67_content"><div class="location-link"><strong>__fput+0x1e6/0x2c0:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/internal.h#L112" target="_blank">file_put_write_access&nbsp;at&nbsp;fs/internal.h:112</a><div class="source-line"> 107 	void backing_file_set_user_path(struct file *f, const struct path *path);</div><div class="source-line"> 108</div><div class="source-line"> 109 	static inline void file_put_write_access(struct file *file)</div><div class="source-line"> 110 	{</div><div class="source-line"> 111 		put_write_access(file-&gt;f_inode);</div><div class="source-line current-line">&gt;112&lt;		mnt_put_write_access(file-&gt;f_path.mnt);</div><div class="source-line"> 113 		if (unlikely(file-&gt;f_mode &amp; FMODE_BACKING))</div><div class="source-line"> 114 			mnt_put_write_access(backing_file_user_path(file)-&gt;mnt);</div><div class="source-line"> 115 	}</div><div class="source-line"> 116</div><div class="source-line"> 117 	static inline void put_file_access(struct file *file)</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/internal.h#L122" target="_blank">(inlined&nbsp;by)&nbsp;put_file_access&nbsp;at&nbsp;fs/internal.h:122</a><div class="source-line"> 117 	static inline void put_file_access(struct file *file)</div><div class="source-line"> 118 	{</div><div class="source-line"> 119 		if ((file-&gt;f_mode &amp; (FMODE_READ | FMODE_WRITE)) == FMODE_READ) {</div><div class="source-line"> 120 			i_readcount_dec(file-&gt;f_inode);</div><div class="source-line"> 121 		} else if (file-&gt;f_mode &amp; FMODE_WRITER) {</div><div class="source-line current-line">&gt;122&lt;			file_put_write_access(file);</div><div class="source-line"> 123 		}</div><div class="source-line"> 124 	}</div><div class="source-line"> 125</div><div class="source-line"> 126 	void fput_close_sync(struct file *);</div><div class="source-line"> 127 	void fput_close(struct file *);</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/file_table.c#L475" target="_blank">(inlined&nbsp;by)&nbsp;__fput&nbsp;at&nbsp;fs/file_table.c:475</a><div class="source-line"> 470 			     !(mode &amp; FMODE_PATH))) {</div><div class="source-line"> 471 			cdev_put(inode-&gt;i_cdev);</div><div class="source-line"> 472 		}</div><div class="source-line"> 473 		fops_put(file-&gt;f_op);</div><div class="source-line"> 474 		file_f_owner_release(file);</div><div class="source-line current-line">&gt;475&lt;		put_file_access(file);</div><div class="source-line"> 476 		dput(dentry);</div><div class="source-line"> 477 		if (unlikely(mode &amp; FMODE_NEED_UNMOUNT))</div><div class="source-line"> 478 			dissolve_on_fput(mnt);</div><div class="source-line"> 479 		mntput(mnt);</div><div class="source-line"> 480 	out:</div><div style="height: 10px;"></div></div><div class="line-container" id="line_68_container"><span class="line-number">69</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.079&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preempt_count_add();&nbsp;/*&nbsp;&lt;-mnt_put_write_access+0x17/0x50&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_68')">+</span></div><div class="expanded-content" id="line_68_content"><div class="location-link"><strong>mnt_put_write_access+0x16/0x50:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/namespace.c#L561" target="_blank">mnt_put_write_access&nbsp;at&nbsp;fs/namespace.c:561</a><div class="source-line"> 556 	 * performing writes to it.  Must be matched with</div><div class="source-line"> 557 	 * mnt_get_write_access() call above.</div><div class="source-line"> 558 	 */</div><div class="source-line"> 559 	void mnt_put_write_access(struct vfsmount *mnt)</div><div class="source-line"> 560 	{</div><div class="source-line current-line">&gt;561&lt;		preempt_disable();</div><div class="source-line"> 562 		mnt_dec_writers(real_mount(mnt));</div><div class="source-line"> 563 		preempt_enable();</div><div class="source-line"> 564 	}</div><div class="source-line"> 565 	EXPORT_SYMBOL_GPL(mnt_put_write_access);</div><div class="source-line"> 566</div><div style="height: 10px;"></div></div><div class="line-container" id="line_69_container"><span class="line-number">70</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.077&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preempt_count_sub();&nbsp;/*&nbsp;&lt;-mnt_put_write_access+0x29/0x50&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_69')">+</span></div><div class="expanded-content" id="line_69_content"><div class="location-link"><strong>mnt_put_write_access+0x28/0x50:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/namespace.c#L563" target="_blank">mnt_put_write_access&nbsp;at&nbsp;fs/namespace.c:563</a><div class="source-line"> 558 	 */</div><div class="source-line"> 559 	void mnt_put_write_access(struct vfsmount *mnt)</div><div class="source-line"> 560 	{</div><div class="source-line"> 561 		preempt_disable();</div><div class="source-line"> 562 		mnt_dec_writers(real_mount(mnt));</div><div class="source-line current-line">&gt;563&lt;		preempt_enable();</div><div class="source-line"> 564 	}</div><div class="source-line"> 565 	EXPORT_SYMBOL_GPL(mnt_put_write_access);</div><div class="source-line"> 566</div><div class="source-line"> 567 	/**</div><div class="source-line"> 568 	 * mnt_drop_write - give up write access to a mount</div><div style="height: 10px;"></div></div><div class="line-container" id="line_70_container"><span class="line-number">71</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.610&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;mnt_put_write_access&nbsp;*/</span></div><div class="line-container" id="line_71_container"><span class="line-number">72</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dput()&nbsp;{&nbsp;/*&nbsp;&lt;-__fput+0x141/0x2c0&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_71')">+</span></div><div class="expanded-content" id="line_71_content"><div class="location-link"><strong>__fput+0x140/0x2c0:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/file_table.c#L476" target="_blank">__fput&nbsp;at&nbsp;fs/file_table.c:476</a><div class="source-line"> 471 			cdev_put(inode-&gt;i_cdev);</div><div class="source-line"> 472 		}</div><div class="source-line"> 473 		fops_put(file-&gt;f_op);</div><div class="source-line"> 474 		file_f_owner_release(file);</div><div class="source-line"> 475 		put_file_access(file);</div><div class="source-line current-line">&gt;476&lt;		dput(dentry);</div><div class="source-line"> 477 		if (unlikely(mode &amp; FMODE_NEED_UNMOUNT))</div><div class="source-line"> 478 			dissolve_on_fput(mnt);</div><div class="source-line"> 479 		mntput(mnt);</div><div class="source-line"> 480 	out:</div><div class="source-line"> 481 		file_free(file);</div><div style="height: 10px;"></div></div><div class="line-container" id="line_72_container"><span class="line-number">73</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.073&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__cond_resched();&nbsp;/*&nbsp;&lt;-dput+0x1e/0x220&nbsp;ret=0&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_72')">+</span></div><div class="expanded-content" id="line_72_content"><div class="location-link"><strong>dput+0x1d/0x220:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/kernel.h#L61" target="_blank">might_resched&nbsp;at&nbsp;./include/linux/kernel.h:61</a><div class="source-line"> 56</div><div class="source-line"> 57 	DECLARE_STATIC_CALL(might_resched, __cond_resched);</div><div class="source-line"> 58</div><div class="source-line"> 59 	static __always_inline void might_resched(void)</div><div class="source-line"> 60 	{</div><div class="source-line current-line">&gt;61&lt;		static_call_mod(might_resched)();</div><div class="source-line"> 62 	}</div><div class="source-line"> 63</div><div class="source-line"> 64 	#elif defined(CONFIG_PREEMPT_DYNAMIC) &amp;&amp; defined(CONFIG_HAVE_PREEMPT_DYNAMIC_KEY)</div><div class="source-line"> 65</div><div class="source-line"> 66 	extern int dynamic_might_resched(void);</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/dcache.c#L922" target="_blank">(inlined&nbsp;by)&nbsp;dput&nbsp;at&nbsp;fs/dcache.c:922</a><div class="source-line"> 917 	 */</div><div class="source-line"> 918 	void dput(struct dentry *dentry)</div><div class="source-line"> 919 	{</div><div class="source-line"> 920 		if (!dentry)</div><div class="source-line"> 921 			return;</div><div class="source-line current-line">&gt;922&lt;		might_sleep();</div><div class="source-line"> 923 		rcu_read_lock();</div><div class="source-line"> 924 		if (likely(fast_dput(dentry))) {</div><div class="source-line"> 925 			rcu_read_unlock();</div><div class="source-line"> 926 			return;</div><div class="source-line"> 927 		}</div><div style="height: 10px;"></div></div><div class="line-container" id="line_73_container"><span class="line-number">74</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.074&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__rcu_read_lock();&nbsp;/*&nbsp;&lt;-dput+0x23/0x220&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_73')">+</span></div><div class="expanded-content" id="line_73_content"><div class="location-link"><strong>dput+0x22/0x220:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/rcupdate.h#L865" target="_blank">rcu_read_lock&nbsp;at&nbsp;./include/linux/rcupdate.h:865</a><div class="source-line"> 860 	 * read-side critical sections may be preempted and they may also block, but</div><div class="source-line"> 861 	 * only when acquiring spinlocks that are subject to priority inheritance.</div><div class="source-line"> 862 	 */</div><div class="source-line"> 863 	static __always_inline void rcu_read_lock(void)</div><div class="source-line"> 864 	{</div><div class="source-line current-line">&gt;865&lt;		__rcu_read_lock();</div><div class="source-line"> 866 		__acquire(RCU);</div><div class="source-line"> 867 		rcu_lock_acquire(&amp;rcu_lock_map);</div><div class="source-line"> 868 		RCU_LOCKDEP_WARN(!rcu_is_watching(),</div><div class="source-line"> 869 				 "rcu_read_lock() used illegally while idle");</div><div class="source-line"> 870 	}</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/dcache.c#L923" target="_blank">(inlined&nbsp;by)&nbsp;dput&nbsp;at&nbsp;fs/dcache.c:923</a><div class="source-line"> 918 	void dput(struct dentry *dentry)</div><div class="source-line"> 919 	{</div><div class="source-line"> 920 		if (!dentry)</div><div class="source-line"> 921 			return;</div><div class="source-line"> 922 		might_sleep();</div><div class="source-line current-line">&gt;923&lt;		rcu_read_lock();</div><div class="source-line"> 924 		if (likely(fast_dput(dentry))) {</div><div class="source-line"> 925 			rcu_read_unlock();</div><div class="source-line"> 926 			return;</div><div class="source-line"> 927 		}</div><div class="source-line"> 928 		finish_dput(dentry);</div><div style="height: 10px;"></div></div><div class="line-container" id="line_74_container"><span class="line-number">75</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_raw_spin_lock()&nbsp;{&nbsp;/*&nbsp;&lt;-dput+0x1e1/0x220&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_74')">+</span></div><div class="expanded-content" id="line_74_content"><div class="location-link"><strong>dput+0x1e0/0x220:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/spinlock.h#L351" target="_blank">spin_lock&nbsp;at&nbsp;./include/linux/spinlock.h:351</a><div class="source-line"> 346</div><div class="source-line"> 347 	#endif</div><div class="source-line"> 348</div><div class="source-line"> 349 	static __always_inline void spin_lock(spinlock_t *lock)</div><div class="source-line"> 350 	{</div><div class="source-line current-line">&gt;351&lt;		raw_spin_lock(&amp;lock-&gt;rlock);</div><div class="source-line"> 352 	}</div><div class="source-line"> 353</div><div class="source-line"> 354 	static __always_inline void spin_lock_bh(spinlock_t *lock)</div><div class="source-line"> 355 	{</div><div class="source-line"> 356 		raw_spin_lock_bh(&amp;lock-&gt;rlock);</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/dcache.c#L828" target="_blank">(inlined&nbsp;by)&nbsp;fast_dput&nbsp;at&nbsp;fs/dcache.c:828</a><div class="source-line"> 823 		 * If the lockref_put_return() failed due to the lock being held</div><div class="source-line"> 824 		 * by somebody else, the fast path has failed. We will need to</div><div class="source-line"> 825 		 * get the lock, and then check the count again.</div><div class="source-line"> 826 		 */</div><div class="source-line"> 827 		if (unlikely(ret &lt; 0)) {</div><div class="source-line current-line">&gt;828&lt;			spin_lock(&amp;dentry-&gt;d_lock);</div><div class="source-line"> 829 			if (WARN_ON_ONCE(dentry-&gt;d_lockref.count &lt;= 0)) {</div><div class="source-line"> 830 				spin_unlock(&amp;dentry-&gt;d_lock);</div><div class="source-line"> 831 				return true;</div><div class="source-line"> 832 			}</div><div class="source-line"> 833 			dentry-&gt;d_lockref.count--;</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/dcache.c#L924" target="_blank">(inlined&nbsp;by)&nbsp;dput&nbsp;at&nbsp;fs/dcache.c:924</a><div class="source-line"> 919 	{</div><div class="source-line"> 920 		if (!dentry)</div><div class="source-line"> 921 			return;</div><div class="source-line"> 922 		might_sleep();</div><div class="source-line"> 923 		rcu_read_lock();</div><div class="source-line current-line">&gt;924&lt;		if (likely(fast_dput(dentry))) {</div><div class="source-line"> 925 			rcu_read_unlock();</div><div class="source-line"> 926 			return;</div><div class="source-line"> 927 		}</div><div class="source-line"> 928 		finish_dput(dentry);</div><div class="source-line"> 929 	}</div><div style="height: 10px;"></div></div><div class="line-container" id="line_75_container"><span class="line-number">76</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.077&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preempt_count_add();&nbsp;/*&nbsp;&lt;-_raw_spin_lock+0x17/0x40&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_75')">+</span></div><div class="expanded-content" id="line_75_content"><div class="location-link"><strong>_raw_spin_lock+0x16/0x40:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/spinlock_api_smp.h#L132" target="_blank">__raw_spin_lock&nbsp;at&nbsp;./include/linux/spinlock_api_smp.h:132</a><div class="source-line"> 127 		LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</div><div class="source-line"> 128 	}</div><div class="source-line"> 129</div><div class="source-line"> 130 	static inline void __raw_spin_lock(raw_spinlock_t *lock)</div><div class="source-line"> 131 	{</div><div class="source-line current-line">&gt;132&lt;		preempt_disable();</div><div class="source-line"> 133 		spin_acquire(&amp;lock-&gt;dep_map, 0, 0, _RET_IP_);</div><div class="source-line"> 134 		LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</div><div class="source-line"> 135 	}</div><div class="source-line"> 136</div><div class="source-line"> 137 	#endif /* !CONFIG_GENERIC_LOCKBREAK || CONFIG_DEBUG_LOCK_ALLOC */</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/locking/spinlock.c#L154" target="_blank">(inlined&nbsp;by)&nbsp;_raw_spin_lock&nbsp;at&nbsp;kernel/locking/spinlock.c:154</a><div class="source-line"> 149 	#endif</div><div class="source-line"> 150</div><div class="source-line"> 151 	#ifndef CONFIG_INLINE_SPIN_LOCK</div><div class="source-line"> 152 	noinline void __lockfunc _raw_spin_lock(raw_spinlock_t *lock)</div><div class="source-line"> 153 	{</div><div class="source-line current-line">&gt;154&lt;		__raw_spin_lock(lock);</div><div class="source-line"> 155 	}</div><div class="source-line"> 156 	EXPORT_SYMBOL(_raw_spin_lock);</div><div class="source-line"> 157 	#endif</div><div class="source-line"> 158</div><div class="source-line"> 159 	#ifndef CONFIG_INLINE_SPIN_LOCK_IRQSAVE</div><div style="height: 10px;"></div></div><div class="line-container" id="line_76_container"><span class="line-number">77</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.085&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do_raw_spin_lock();&nbsp;/*&nbsp;&lt;-dput+0x1e1/0x220&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_76')">+</span></div><div class="expanded-content" id="line_76_content"><div class="location-link"><strong>dput+0x1e0/0x220:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/spinlock.h#L351" target="_blank">spin_lock&nbsp;at&nbsp;./include/linux/spinlock.h:351</a><div class="source-line"> 346</div><div class="source-line"> 347 	#endif</div><div class="source-line"> 348</div><div class="source-line"> 349 	static __always_inline void spin_lock(spinlock_t *lock)</div><div class="source-line"> 350 	{</div><div class="source-line current-line">&gt;351&lt;		raw_spin_lock(&amp;lock-&gt;rlock);</div><div class="source-line"> 352 	}</div><div class="source-line"> 353</div><div class="source-line"> 354 	static __always_inline void spin_lock_bh(spinlock_t *lock)</div><div class="source-line"> 355 	{</div><div class="source-line"> 356 		raw_spin_lock_bh(&amp;lock-&gt;rlock);</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/dcache.c#L828" target="_blank">(inlined&nbsp;by)&nbsp;fast_dput&nbsp;at&nbsp;fs/dcache.c:828</a><div class="source-line"> 823 		 * If the lockref_put_return() failed due to the lock being held</div><div class="source-line"> 824 		 * by somebody else, the fast path has failed. We will need to</div><div class="source-line"> 825 		 * get the lock, and then check the count again.</div><div class="source-line"> 826 		 */</div><div class="source-line"> 827 		if (unlikely(ret &lt; 0)) {</div><div class="source-line current-line">&gt;828&lt;			spin_lock(&amp;dentry-&gt;d_lock);</div><div class="source-line"> 829 			if (WARN_ON_ONCE(dentry-&gt;d_lockref.count &lt;= 0)) {</div><div class="source-line"> 830 				spin_unlock(&amp;dentry-&gt;d_lock);</div><div class="source-line"> 831 				return true;</div><div class="source-line"> 832 			}</div><div class="source-line"> 833 			dentry-&gt;d_lockref.count--;</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/dcache.c#L924" target="_blank">(inlined&nbsp;by)&nbsp;dput&nbsp;at&nbsp;fs/dcache.c:924</a><div class="source-line"> 919 	{</div><div class="source-line"> 920 		if (!dentry)</div><div class="source-line"> 921 			return;</div><div class="source-line"> 922 		might_sleep();</div><div class="source-line"> 923 		rcu_read_lock();</div><div class="source-line current-line">&gt;924&lt;		if (likely(fast_dput(dentry))) {</div><div class="source-line"> 925 			rcu_read_unlock();</div><div class="source-line"> 926 			return;</div><div class="source-line"> 927 		}</div><div class="source-line"> 928 		finish_dput(dentry);</div><div class="source-line"> 929 	}</div><div style="height: 10px;"></div></div><div class="line-container" id="line_77_container"><span class="line-number">78</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.453&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;_raw_spin_lock&nbsp;*/</span></div><div class="line-container" id="line_78_container"><span class="line-number">79</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_raw_spin_unlock()&nbsp;{&nbsp;/*&nbsp;&lt;-dput+0x108/0x220&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_78')">+</span></div><div class="expanded-content" id="line_78_content"><div class="location-link"><strong>dput+0x107/0x220:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/spinlock.h#L391" target="_blank">spin_unlock&nbsp;at&nbsp;./include/linux/spinlock.h:391</a><div class="source-line"> 386 		raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \</div><div class="source-line"> 387 	} while (0)</div><div class="source-line"> 388</div><div class="source-line"> 389 	static __always_inline void spin_unlock(spinlock_t *lock)</div><div class="source-line"> 390 	{</div><div class="source-line current-line">&gt;391&lt;		raw_spin_unlock(&amp;lock-&gt;rlock);</div><div class="source-line"> 392 	}</div><div class="source-line"> 393</div><div class="source-line"> 394 	static __always_inline void spin_unlock_bh(spinlock_t *lock)</div><div class="source-line"> 395 	{</div><div class="source-line"> 396 		raw_spin_unlock_bh(&amp;lock-&gt;rlock);</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/dcache.c#L867" target="_blank">(inlined&nbsp;by)&nbsp;fast_dput&nbsp;at&nbsp;fs/dcache.c:867</a><div class="source-line"> 862 		 * else could have killed it and marked it dead. Either way, we</div><div class="source-line"> 863 		 * don't need to do anything else.</div><div class="source-line"> 864 		 */</div><div class="source-line"> 865 	locked:</div><div class="source-line"> 866 		if (dentry-&gt;d_lockref.count || retain_dentry(dentry, true)) {</div><div class="source-line current-line">&gt;867&lt;			spin_unlock(&amp;dentry-&gt;d_lock);</div><div class="source-line"> 868 			return true;</div><div class="source-line"> 869 		}</div><div class="source-line"> 870 		return false;</div><div class="source-line"> 871 	}</div><div class="source-line"> 872</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/dcache.c#L924" target="_blank">(inlined&nbsp;by)&nbsp;dput&nbsp;at&nbsp;fs/dcache.c:924</a><div class="source-line"> 919 	{</div><div class="source-line"> 920 		if (!dentry)</div><div class="source-line"> 921 			return;</div><div class="source-line"> 922 		might_sleep();</div><div class="source-line"> 923 		rcu_read_lock();</div><div class="source-line current-line">&gt;924&lt;		if (likely(fast_dput(dentry))) {</div><div class="source-line"> 925 			rcu_read_unlock();</div><div class="source-line"> 926 			return;</div><div class="source-line"> 927 		}</div><div class="source-line"> 928 		finish_dput(dentry);</div><div class="source-line"> 929 	}</div><div style="height: 10px;"></div></div><div class="line-container" id="line_79_container"><span class="line-number">80</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.074&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do_raw_spin_unlock();&nbsp;/*&nbsp;&lt;-_raw_spin_unlock+0x23/0x50&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_79')">+</span></div><div class="expanded-content" id="line_79_content"><div class="location-link"><strong>_raw_spin_unlock+0x22/0x50:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/spinlock_api_smp.h#L142" target="_blank">__raw_spin_unlock&nbsp;at&nbsp;./include/linux/spinlock_api_smp.h:142</a><div class="source-line"> 137 	#endif /* !CONFIG_GENERIC_LOCKBREAK || CONFIG_DEBUG_LOCK_ALLOC */</div><div class="source-line"> 138</div><div class="source-line"> 139 	static inline void __raw_spin_unlock(raw_spinlock_t *lock)</div><div class="source-line"> 140 	{</div><div class="source-line"> 141 		spin_release(&amp;lock-&gt;dep_map, _RET_IP_);</div><div class="source-line current-line">&gt;142&lt;		do_raw_spin_unlock(lock);</div><div class="source-line"> 143 		preempt_enable();</div><div class="source-line"> 144 	}</div><div class="source-line"> 145</div><div class="source-line"> 146 	static inline void __raw_spin_unlock_irqrestore(raw_spinlock_t *lock,</div><div class="source-line"> 147 						    unsigned long flags)</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/locking/spinlock.c#L186" target="_blank">(inlined&nbsp;by)&nbsp;_raw_spin_unlock&nbsp;at&nbsp;kernel/locking/spinlock.c:186</a><div class="source-line"> 181 	#endif</div><div class="source-line"> 182</div><div class="source-line"> 183 	#ifdef CONFIG_UNINLINE_SPIN_UNLOCK</div><div class="source-line"> 184 	noinline void __lockfunc _raw_spin_unlock(raw_spinlock_t *lock)</div><div class="source-line"> 185 	{</div><div class="source-line current-line">&gt;186&lt;		__raw_spin_unlock(lock);</div><div class="source-line"> 187 	}</div><div class="source-line"> 188 	EXPORT_SYMBOL(_raw_spin_unlock);</div><div class="source-line"> 189 	#endif</div><div class="source-line"> 190</div><div class="source-line"> 191 	#ifndef CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE</div><div style="height: 10px;"></div></div><div class="line-container" id="line_80_container"><span class="line-number">81</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.075&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preempt_count_sub();&nbsp;/*&nbsp;&lt;-_raw_spin_unlock+0x2d/0x50&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_80')">+</span></div><div class="expanded-content" id="line_80_content"><div class="location-link"><strong>_raw_spin_unlock+0x2c/0x50:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/spinlock_api_smp.h#L143" target="_blank">__raw_spin_unlock&nbsp;at&nbsp;./include/linux/spinlock_api_smp.h:143</a><div class="source-line"> 138</div><div class="source-line"> 139 	static inline void __raw_spin_unlock(raw_spinlock_t *lock)</div><div class="source-line"> 140 	{</div><div class="source-line"> 141 		spin_release(&amp;lock-&gt;dep_map, _RET_IP_);</div><div class="source-line"> 142 		do_raw_spin_unlock(lock);</div><div class="source-line current-line">&gt;143&lt;		preempt_enable();</div><div class="source-line"> 144 	}</div><div class="source-line"> 145</div><div class="source-line"> 146 	static inline void __raw_spin_unlock_irqrestore(raw_spinlock_t *lock,</div><div class="source-line"> 147 						    unsigned long flags)</div><div class="source-line"> 148 	{</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/kernel/locking/spinlock.c#L186" target="_blank">(inlined&nbsp;by)&nbsp;_raw_spin_unlock&nbsp;at&nbsp;kernel/locking/spinlock.c:186</a><div class="source-line"> 181 	#endif</div><div class="source-line"> 182</div><div class="source-line"> 183 	#ifdef CONFIG_UNINLINE_SPIN_UNLOCK</div><div class="source-line"> 184 	noinline void __lockfunc _raw_spin_unlock(raw_spinlock_t *lock)</div><div class="source-line"> 185 	{</div><div class="source-line current-line">&gt;186&lt;		__raw_spin_unlock(lock);</div><div class="source-line"> 187 	}</div><div class="source-line"> 188 	EXPORT_SYMBOL(_raw_spin_unlock);</div><div class="source-line"> 189 	#endif</div><div class="source-line"> 190</div><div class="source-line"> 191 	#ifndef CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE</div><div style="height: 10px;"></div></div><div class="line-container" id="line_81_container"><span class="line-number">82</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.397&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;_raw_spin_unlock&nbsp;*/</span></div><div class="line-container" id="line_82_container"><span class="line-number">83</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.078&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__rcu_read_unlock();&nbsp;/*&nbsp;&lt;-__fput+0x141/0x2c0&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_82')">+</span></div><div class="expanded-content" id="line_82_content"><div class="location-link"><strong>__fput+0x140/0x2c0:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/file_table.c#L476" target="_blank">__fput&nbsp;at&nbsp;fs/file_table.c:476</a><div class="source-line"> 471 			cdev_put(inode-&gt;i_cdev);</div><div class="source-line"> 472 		}</div><div class="source-line"> 473 		fops_put(file-&gt;f_op);</div><div class="source-line"> 474 		file_f_owner_release(file);</div><div class="source-line"> 475 		put_file_access(file);</div><div class="source-line current-line">&gt;476&lt;		dput(dentry);</div><div class="source-line"> 477 		if (unlikely(mode &amp; FMODE_NEED_UNMOUNT))</div><div class="source-line"> 478 			dissolve_on_fput(mnt);</div><div class="source-line"> 479 		mntput(mnt);</div><div class="source-line"> 480 	out:</div><div class="source-line"> 481 		file_free(file);</div><div style="height: 10px;"></div></div><div class="line-container" id="line_83_container"><span class="line-number">84</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;1.621&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;dput&nbsp;*/</span></div><div class="line-container" id="line_84_container"><span class="line-number">85</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mntput()&nbsp;{&nbsp;/*&nbsp;&lt;-__fput+0x155/0x2c0&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_84')">+</span></div><div class="expanded-content" id="line_84_content"><div class="location-link"><strong>__fput+0x154/0x2c0:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/file_table.c#L479" target="_blank">__fput&nbsp;at&nbsp;fs/file_table.c:479</a><div class="source-line"> 474 		file_f_owner_release(file);</div><div class="source-line"> 475 		put_file_access(file);</div><div class="source-line"> 476 		dput(dentry);</div><div class="source-line"> 477 		if (unlikely(mode &amp; FMODE_NEED_UNMOUNT))</div><div class="source-line"> 478 			dissolve_on_fput(mnt);</div><div class="source-line current-line">&gt;479&lt;		mntput(mnt);</div><div class="source-line"> 480 	out:</div><div class="source-line"> 481 		file_free(file);</div><div class="source-line"> 482 	}</div><div class="source-line"> 483</div><div class="source-line"> 484 	static LLIST_HEAD(delayed_fput_list);</div><div style="height: 10px;"></div></div><div class="line-container" id="line_85_container"><span class="line-number">86</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mntput_no_expire()&nbsp;{&nbsp;/*&nbsp;&lt;-__fput+0x155/0x2c0&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_85')">+</span></div><div class="expanded-content" id="line_85_content"><div class="location-link"><strong>__fput+0x154/0x2c0:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/file_table.c#L479" target="_blank">__fput&nbsp;at&nbsp;fs/file_table.c:479</a><div class="source-line"> 474 		file_f_owner_release(file);</div><div class="source-line"> 475 		put_file_access(file);</div><div class="source-line"> 476 		dput(dentry);</div><div class="source-line"> 477 		if (unlikely(mode &amp; FMODE_NEED_UNMOUNT))</div><div class="source-line"> 478 			dissolve_on_fput(mnt);</div><div class="source-line current-line">&gt;479&lt;		mntput(mnt);</div><div class="source-line"> 480 	out:</div><div class="source-line"> 481 		file_free(file);</div><div class="source-line"> 482 	}</div><div class="source-line"> 483</div><div class="source-line"> 484 	static LLIST_HEAD(delayed_fput_list);</div><div style="height: 10px;"></div></div><div class="line-container" id="line_86_container"><span class="line-number">87</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.073&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__rcu_read_lock();&nbsp;/*&nbsp;&lt;-mntput_no_expire+0xe/0x100&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_86')">+</span></div><div class="expanded-content" id="line_86_content"><div class="location-link"><strong>mntput_no_expire+0xd/0x100:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/rcupdate.h#L865" target="_blank">rcu_read_lock&nbsp;at&nbsp;./include/linux/rcupdate.h:865</a><div class="source-line"> 860 	 * read-side critical sections may be preempted and they may also block, but</div><div class="source-line"> 861 	 * only when acquiring spinlocks that are subject to priority inheritance.</div><div class="source-line"> 862 	 */</div><div class="source-line"> 863 	static __always_inline void rcu_read_lock(void)</div><div class="source-line"> 864 	{</div><div class="source-line current-line">&gt;865&lt;		__rcu_read_lock();</div><div class="source-line"> 866 		__acquire(RCU);</div><div class="source-line"> 867 		rcu_lock_acquire(&amp;rcu_lock_map);</div><div class="source-line"> 868 		RCU_LOCKDEP_WARN(!rcu_is_watching(),</div><div class="source-line"> 869 				 "rcu_read_lock() used illegally while idle");</div><div class="source-line"> 870 	}</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/namespace.c#L1397" target="_blank">(inlined&nbsp;by)&nbsp;mntput_no_expire&nbsp;at&nbsp;fs/namespace.c:1397</a><div class="source-line"> 1392 		cleanup_mnt(mnt);</div><div class="source-line"> 1393 	}</div><div class="source-line"> 1394</div><div class="source-line"> 1395 	static void mntput_no_expire(struct mount *mnt)</div><div class="source-line"> 1396 	{</div><div class="source-line current-line">&gt;1397&lt;		rcu_read_lock();</div><div class="source-line"> 1398 		if (likely(READ_ONCE(mnt-&gt;mnt_ns))) {</div><div class="source-line"> 1399 			/*</div><div class="source-line"> 1400 			 * Since we don't do lock_mount_hash() here,</div><div class="source-line"> 1401 			 * -&gt;mnt_ns can change under us.  However, if it's</div><div class="source-line"> 1402 			 * non-NULL, then there's a reference that won't</div><div style="height: 10px;"></div></div><div class="line-container" id="line_87_container"><span class="line-number">88</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.089&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__rcu_read_unlock();&nbsp;/*&nbsp;&lt;-__fput+0x155/0x2c0&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_87')">+</span></div><div class="expanded-content" id="line_87_content"><div class="location-link"><strong>__fput+0x154/0x2c0:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/file_table.c#L479" target="_blank">__fput&nbsp;at&nbsp;fs/file_table.c:479</a><div class="source-line"> 474 		file_f_owner_release(file);</div><div class="source-line"> 475 		put_file_access(file);</div><div class="source-line"> 476 		dput(dentry);</div><div class="source-line"> 477 		if (unlikely(mode &amp; FMODE_NEED_UNMOUNT))</div><div class="source-line"> 478 			dissolve_on_fput(mnt);</div><div class="source-line current-line">&gt;479&lt;		mntput(mnt);</div><div class="source-line"> 480 	out:</div><div class="source-line"> 481 		file_free(file);</div><div class="source-line"> 482 	}</div><div class="source-line"> 483</div><div class="source-line"> 484 	static LLIST_HEAD(delayed_fput_list);</div><div style="height: 10px;"></div></div><div class="line-container" id="line_88_container"><span class="line-number">89</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.447&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;mntput_no_expire&nbsp;*/</span></div><div class="line-container" id="line_89_container"><span class="line-number">90</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.592&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;mntput&nbsp;*/</span></div><div class="line-container" id="line_90_container"><span class="line-number">91</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;security_file_free()&nbsp;{&nbsp;/*&nbsp;&lt;-__fput+0x15d/0x2c0&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_90')">+</span></div><div class="expanded-content" id="line_90_content"><div class="location-link"><strong>__fput+0x15c/0x2c0:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/file_table.c#L71" target="_blank">file_free&nbsp;at&nbsp;fs/file_table.c:71</a><div class="source-line"> 66 	}</div><div class="source-line"> 67 	EXPORT_SYMBOL_GPL(backing_file_set_user_path);</div><div class="source-line"> 68</div><div class="source-line"> 69 	static inline void file_free(struct file *f)</div><div class="source-line"> 70 	{</div><div class="source-line current-line">&gt;71&lt;		security_file_free(f);</div><div class="source-line"> 72 		if (likely(!(f-&gt;f_mode &amp; FMODE_NOACCOUNT)))</div><div class="source-line"> 73 			percpu_counter_dec(&amp;nr_files);</div><div class="source-line"> 74 		put_cred(f-&gt;f_cred);</div><div class="source-line"> 75 		if (unlikely(f-&gt;f_mode &amp; FMODE_BACKING)) {</div><div class="source-line"> 76 			path_put(backing_file_user_path(f));</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/file_table.c#L481" target="_blank">(inlined&nbsp;by)&nbsp;__fput&nbsp;at&nbsp;fs/file_table.c:481</a><div class="source-line"> 476 		dput(dentry);</div><div class="source-line"> 477 		if (unlikely(mode &amp; FMODE_NEED_UNMOUNT))</div><div class="source-line"> 478 			dissolve_on_fput(mnt);</div><div class="source-line"> 479 		mntput(mnt);</div><div class="source-line"> 480 	out:</div><div class="source-line current-line">&gt;481&lt;		file_free(file);</div><div class="source-line"> 482 	}</div><div class="source-line"> 483</div><div class="source-line"> 484 	static LLIST_HEAD(delayed_fput_list);</div><div class="source-line"> 485 	static void delayed_fput(struct work_struct *unused)</div><div class="source-line"> 486 	{</div><div style="height: 10px;"></div></div><div class="line-container" id="line_91_container"><span class="line-number">92</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.070&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bpf_lsm_file_free_security();&nbsp;/*&nbsp;&lt;-security_file_free+0x3e/0x70&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_91')">+</span></div><div class="expanded-content" id="line_91_content"><div class="location-link"><strong>security_file_free+0x3d/0x70:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/security/security.c#L2411" target="_blank">security_file_free&nbsp;at&nbsp;security/security.c:2411</a><div class="source-line"> 2406 	 */</div><div class="source-line"> 2407 	void security_file_free(struct file *file)</div><div class="source-line"> 2408 	{</div><div class="source-line"> 2409 		void *blob;</div><div class="source-line"> 2410</div><div class="source-line current-line">&gt;2411&lt;		call_void_hook(file_free_security, file);</div><div class="source-line"> 2412</div><div class="source-line"> 2413 		blob = file-&gt;f_security;</div><div class="source-line"> 2414 		if (blob) {</div><div class="source-line"> 2415 			file-&gt;f_security = NULL;</div><div class="source-line"> 2416 			kmem_cache_free(lsm_file_cache, blob);</div><div style="height: 10px;"></div></div><div class="line-container" id="line_92_container"><span class="line-number">93</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kmem_cache_free()&nbsp;{&nbsp;/*&nbsp;&lt;-__fput+0x15d/0x2c0&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_92')">+</span></div><div class="expanded-content" id="line_92_content"><div class="location-link"><strong>__fput+0x15c/0x2c0:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/file_table.c#L71" target="_blank">file_free&nbsp;at&nbsp;fs/file_table.c:71</a><div class="source-line"> 66 	}</div><div class="source-line"> 67 	EXPORT_SYMBOL_GPL(backing_file_set_user_path);</div><div class="source-line"> 68</div><div class="source-line"> 69 	static inline void file_free(struct file *f)</div><div class="source-line"> 70 	{</div><div class="source-line current-line">&gt;71&lt;		security_file_free(f);</div><div class="source-line"> 72 		if (likely(!(f-&gt;f_mode &amp; FMODE_NOACCOUNT)))</div><div class="source-line"> 73 			percpu_counter_dec(&amp;nr_files);</div><div class="source-line"> 74 		put_cred(f-&gt;f_cred);</div><div class="source-line"> 75 		if (unlikely(f-&gt;f_mode &amp; FMODE_BACKING)) {</div><div class="source-line"> 76 			path_put(backing_file_user_path(f));</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/fs/file_table.c#L481" target="_blank">(inlined&nbsp;by)&nbsp;__fput&nbsp;at&nbsp;fs/file_table.c:481</a><div class="source-line"> 476 		dput(dentry);</div><div class="source-line"> 477 		if (unlikely(mode &amp; FMODE_NEED_UNMOUNT))</div><div class="source-line"> 478 			dissolve_on_fput(mnt);</div><div class="source-line"> 479 		mntput(mnt);</div><div class="source-line"> 480 	out:</div><div class="source-line current-line">&gt;481&lt;		file_free(file);</div><div class="source-line"> 482 	}</div><div class="source-line"> 483</div><div class="source-line"> 484 	static LLIST_HEAD(delayed_fput_list);</div><div class="source-line"> 485 	static void delayed_fput(struct work_struct *unused)</div><div class="source-line"> 486 	{</div><div style="height: 10px;"></div></div><div class="line-container" id="line_93_container"><span class="line-number">94</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.072&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kmemleak_free();&nbsp;/*&nbsp;&lt;-kmem_cache_free+0x26f/0x5f0&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_93')">+</span></div><div class="expanded-content" id="line_93_content"><div class="location-link"><strong>kmem_cache_free+0x26e/0x5f0:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/./include/linux/kmemleak.h#L50" target="_blank">kmemleak_free_recursive&nbsp;at&nbsp;./include/linux/kmemleak.h:50</a><div class="source-line"> 45 	}</div><div class="source-line"> 46</div><div class="source-line"> 47 	static inline void kmemleak_free_recursive(const void *ptr, slab_flags_t flags)</div><div class="source-line"> 48 	{</div><div class="source-line"> 49 		if (!(flags &amp; SLAB_NOLEAKTRACE))</div><div class="source-line current-line">&gt;50&lt;			kmemleak_free(ptr);</div><div class="source-line"> 51 	}</div><div class="source-line"> 52</div><div class="source-line"> 53 	static inline void kmemleak_erase(void **ptr)</div><div class="source-line"> 54 	{</div><div class="source-line"> 55 		*ptr = NULL;</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/mm/slub.c#L2465" target="_blank">(inlined&nbsp;by)&nbsp;slab_free_hook&nbsp;at&nbsp;mm/slub.c:2465</a><div class="source-line"> 2460 			    bool after_rcu_delay)</div><div class="source-line"> 2461 	{</div><div class="source-line"> 2462 		/* Are the object contents still accessible? */</div><div class="source-line"> 2463 		bool still_accessible = (s-&gt;flags &amp; SLAB_TYPESAFE_BY_RCU) &amp;&amp; !after_rcu_delay;</div><div class="source-line"> 2464</div><div class="source-line current-line">&gt;2465&lt;		kmemleak_free_recursive(x, s-&gt;flags);</div><div class="source-line"> 2466 		kmsan_slab_free(s, x);</div><div class="source-line"> 2467</div><div class="source-line"> 2468 		debug_check_no_locks_freed(x, s-&gt;object_size);</div><div class="source-line"> 2469</div><div class="source-line"> 2470 		if (!(s-&gt;flags &amp; SLAB_DEBUG_OBJECTS))</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/mm/slub.c#L6668" target="_blank">(inlined&nbsp;by)&nbsp;slab_free&nbsp;at&nbsp;mm/slub.c:6668</a><div class="source-line"> 6663 		       unsigned long addr)</div><div class="source-line"> 6664 	{</div><div class="source-line"> 6665 		memcg_slab_free_hook(s, slab, &amp;object, 1);</div><div class="source-line"> 6666 		alloc_tagging_slab_free_hook(s, slab, &amp;object, 1);</div><div class="source-line"> 6667</div><div class="source-line current-line">&gt;6668&lt;		if (unlikely(!slab_free_hook(s, object, slab_want_init_on_free(s), false)))</div><div class="source-line"> 6669 			return;</div><div class="source-line"> 6670</div><div class="source-line"> 6671 		if (s-&gt;cpu_sheaves &amp;&amp; likely(!IS_ENABLED(CONFIG_NUMA) ||</div><div class="source-line"> 6672 					     slab_nid(slab) == numa_mem_id())</div><div class="source-line"> 6673 				   &amp;&amp; likely(!slab_test_pfmemalloc(slab))) {</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/mm/slub.c#L6779" target="_blank">(inlined&nbsp;by)&nbsp;kmem_cache_free&nbsp;at&nbsp;mm/slub.c:6779</a><div class="source-line"> 6774 	{</div><div class="source-line"> 6775 		s = cache_from_obj(s, x);</div><div class="source-line"> 6776 		if (!s)</div><div class="source-line"> 6777 			return;</div><div class="source-line"> 6778 		trace_kmem_cache_free(_RET_IP_, x, s);</div><div class="source-line current-line">&gt;6779&lt;		slab_free(s, virt_to_slab(x), x, _RET_IP_);</div><div class="source-line"> 6780 	}</div><div class="source-line"> 6781 	EXPORT_SYMBOL(kmem_cache_free);</div><div class="source-line"> 6782</div><div class="source-line"> 6783 	static void free_large_kmalloc(struct page *page, void *object)</div><div class="source-line"> 6784 	{</div><div style="height: 10px;"></div></div><div class="line-container" id="line_94_container"><span class="line-number">95</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.264&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;kmem_cache_free&nbsp;*/</span></div><div class="line-container" id="line_95_container"><span class="line-number">96</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.560&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;security_file_free&nbsp;*/</span></div><div class="line-container" id="line_96_container"><span class="line-number">97</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kmem_cache_free()&nbsp;{&nbsp;/*&nbsp;&lt;-task_work_run+0x5c/0x90&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_96')">+</span></div><div class="expanded-content" id="line_96_content"><div class="location-link"><strong>task_work_run+0x5b/0x90:</strong></div><div class="source-line">task_work_run at /vol_1t/Qemu/x86_64/bpf_next/kernel/task_work.c:233 (discriminator 1)</div><div class="source-line"> 228 			raw_spin_lock_irq(&amp;task-&gt;pi_lock);</div><div class="source-line"> 229 			raw_spin_unlock_irq(&amp;task-&gt;pi_lock);</div><div class="source-line"> 230</div><div class="source-line"> 231 			do {</div><div class="source-line"> 232 				next = work-&gt;next;</div><div class="source-line current-line">&gt;233&lt;				work-&gt;func(work);</div><div class="source-line"> 234 				work = next;</div><div class="source-line"> 235 				cond_resched();</div><div class="source-line"> 236 			} while (work);</div><div class="source-line"> 237 		}</div><div class="source-line"> 238 	}</div><div style="height: 10px;"></div></div><div class="line-container" id="line_97_container"><span class="line-number">98</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__memcg_slab_free_hook()&nbsp;{&nbsp;/*&nbsp;&lt;-kmem_cache_free+0x42c/0x5f0&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_97')">+</span></div><div class="expanded-content" id="line_97_content"><div class="location-link"><strong>kmem_cache_free+0x42b/0x5f0:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/mm/slub.c#L2364" target="_blank">memcg_slab_free_hook&nbsp;at&nbsp;mm/slub.c:2364</a><div class="source-line"> 2359</div><div class="source-line"> 2360 		obj_exts = slab_obj_exts(slab);</div><div class="source-line"> 2361 		if (likely(!obj_exts))</div><div class="source-line"> 2362 			return;</div><div class="source-line"> 2363</div><div class="source-line current-line">&gt;2364&lt;		__memcg_slab_free_hook(s, slab, p, objects, obj_exts);</div><div class="source-line"> 2365 	}</div><div class="source-line"> 2366</div><div class="source-line"> 2367 	static __fastpath_inline</div><div class="source-line"> 2368 	bool memcg_slab_post_charge(void *p, gfp_t flags)</div><div class="source-line"> 2369 	{</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/mm/slub.c#L6665" target="_blank">(inlined&nbsp;by)&nbsp;slab_free&nbsp;at&nbsp;mm/slub.c:6665</a><div class="source-line"> 6660</div><div class="source-line"> 6661 	static __fastpath_inline</div><div class="source-line"> 6662 	void slab_free(struct kmem_cache *s, struct slab *slab, void *object,</div><div class="source-line"> 6663 		       unsigned long addr)</div><div class="source-line"> 6664 	{</div><div class="source-line current-line">&gt;6665&lt;		memcg_slab_free_hook(s, slab, &amp;object, 1);</div><div class="source-line"> 6666 		alloc_tagging_slab_free_hook(s, slab, &amp;object, 1);</div><div class="source-line"> 6667</div><div class="source-line"> 6668 		if (unlikely(!slab_free_hook(s, object, slab_want_init_on_free(s), false)))</div><div class="source-line"> 6669 			return;</div><div class="source-line"> 6670</div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/mm/slub.c#L6779" target="_blank">(inlined&nbsp;by)&nbsp;kmem_cache_free&nbsp;at&nbsp;mm/slub.c:6779</a><div class="source-line"> 6774 	{</div><div class="source-line"> 6775 		s = cache_from_obj(s, x);</div><div class="source-line"> 6776 		if (!s)</div><div class="source-line"> 6777 			return;</div><div class="source-line"> 6778 		trace_kmem_cache_free(_RET_IP_, x, s);</div><div class="source-line current-line">&gt;6779&lt;		slab_free(s, virt_to_slab(x), x, _RET_IP_);</div><div class="source-line"> 6780 	}</div><div class="source-line"> 6781 	EXPORT_SYMBOL(kmem_cache_free);</div><div class="source-line"> 6782</div><div class="source-line"> 6783 	static void free_large_kmalloc(struct page *page, void *object)</div><div class="source-line"> 6784 	{</div><div style="height: 10px;"></div></div><div class="line-container" id="line_98_container"><span class="line-number">99</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refill_obj_stock()&nbsp;{&nbsp;/*&nbsp;&lt;-__memcg_slab_free_hook+0x104/0x210&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_98')">+</span></div><div class="expanded-content" id="line_98_content"><div class="location-link"><strong>__memcg_slab_free_hook+0x103/0x210:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/mm/memcontrol.c#L3255" target="_blank">__memcg_slab_free_hook&nbsp;at&nbsp;mm/memcontrol.c:3255</a><div class="source-line"> 3250 			objcg = obj_exts[off].objcg;</div><div class="source-line"> 3251 			if (!objcg)</div><div class="source-line"> 3252 				continue;</div><div class="source-line"> 3253</div><div class="source-line"> 3254 			obj_exts[off].objcg = NULL;</div><div class="source-line current-line">&gt;3255&lt;			refill_obj_stock(objcg, obj_size, true, -obj_size,</div><div class="source-line"> 3256 					 slab_pgdat(slab), cache_vmstat_idx(s));</div><div class="source-line"> 3257 			obj_cgroup_put(objcg);</div><div class="source-line"> 3258 		}</div><div class="source-line"> 3259 	}</div><div class="source-line"> 3260</div><div style="height: 10px;"></div></div><div class="line-container" id="line_99_container"><span class="line-number">100</span><span class="line-content">&nbsp;3)&nbsp;&nbsp;&nbsp;0.075&nbsp;us&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preempt_count_add();&nbsp;/*&nbsp;&lt;-refill_obj_stock+0x2f/0x530&nbsp;*/</span><span class="expand-btn" onclick="toggleExpand('line_99')">+</span></div><div class="expanded-content" id="line_99_content"><div class="location-link"><strong>refill_obj_stock+0x2e/0x530:</strong></div><a class="location-link" href="https://elixir.bootlin.com/linux/v6.19-rc1/source/mm/memcontrol.c#L3069" target="_blank">refill_obj_stock&nbsp;at&nbsp;mm/memcontrol.c:3069</a><div class="source-line"> 3064 			enum node_stat_item idx)</div><div class="source-line"> 3065 	{</div><div class="source-line"> 3066 		struct obj_stock_pcp *stock;</div><div class="source-line"> 3067 		unsigned int nr_pages = 0;</div><div class="source-line"> 3068</div><div class="source-line current-line">&gt;3069&lt;		if (!local_trylock(&amp;obj_stock.lock)) {</div><div class="source-line"> 3070 			if (pgdat)</div><div class="source-line"> 3071 				mod_objcg_mlstate(objcg, pgdat, idx, nr_bytes);</div><div class="source-line"> 3072 			nr_pages = nr_bytes &gt;&gt; PAGE_SHIFT;</div><div class="source-line"> 3073 			nr_bytes = nr_bytes &amp; (PAGE_SIZE - 1);</div><div class="source-line"> 3074 			atomic_add(nr_bytes, &amp;objcg-&gt;nr_charged_bytes);</div><div style="height: 10px;"></div></div>
        </div>
    </div>
    
    <script>
        function toggleExpand(lineId) {
            const content = document.getElementById(lineId + '_content');
            const btn = event.target;
            
            if (content.style.display === 'block') {
                content.style.display = 'none';
                btn.textContent = '+';
            } else {
                content.style.display = 'block';
                btn.textContent = '-';
            }
        }
    </script>
</body>
</html>
